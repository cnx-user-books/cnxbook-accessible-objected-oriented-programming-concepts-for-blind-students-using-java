<document xmlns="http://cnx.rice.edu/cnxml"> 
<title>Jbs2050-Runtime Polymorphism with Java Sound</title>
<metadata xmlns:md="http://cnx.rice.edu/mdml">
  <md:content-id>m50935</md:content-id>
  <md:title>Jbs2050-Runtime Polymorphism with Java Sound</md:title>
  <md:abstract>This module demonstrates runtime polymorphism using an array of an abstract type populated with references to objects of eight different subclasses of that abstract type in a format that is accessible to blind students.</md:abstract>
  <md:uuid>6b144587-4bb9-4e60-9206-ef13615412b0</md:uuid>
</metadata>

<content>
















<section id="h11000">
<title>
Table of Contents

</title>




<list id="ul1000" list-type="bulleted">

	

<item id="li1000">
<link id="a1000" target-id="Preface">

Preface

</link>


	

<list id="ul1001" list-type="bulleted">

		

<item id="li1001">
<link id="a1001" target-id="Viewing_tip">

Viewing tip

</link>


<list id="ul1002" list-type="bulleted">


			

<item id="li1002">
<link id="a1002" target-id="Listings">

Listings

</link>


</item>


		

</list>


		

</item>


	

</list>


	

</item>



	

<item id="li1003">
<link id="a1003" target-id="General_background_information">

General background information

</link>


</item>


	

<item id="li1004">
<link id="a1004" target-id="Discussion_and_sample_code">

Discussion and sample code

</link>


<list id="ul1003" list-type="bulleted">

		

<item id="li1005">
<link id="a1005" target-id="The_class_named_MusicComposer08">

The class named MusicComposer08

</link>


<list id="ul1004" list-type="bulleted">

			

<item id="li1006">
<link id="a1006" target-id="Beginning_of_the_class_named_MusicComposer08">

Beginning of the class named MusicComposer08

</link>


</item>


			

<item id="li1007">

			

<link id="a1007" target-id="Create_and_populate_an_array_holding_references_to_audio_objects">

Create and populate an array holding references to audio objects

</link>


</item>


			

<item id="li1008">
<link id="a1008" target-id="Override_an_inherited_abstract_method">

Override an inherited abstract method

</link>


</item>


			

<item id="li1009">

			

<link id="a1009" target-id="Call_the_getMelody_method_on_a_subclass_object_selected_at_random">

Call the getMelody method on a subclass object selected at random

</link>


</item>


			

<item id="li1010">
<link id="a1010" target-id="Some_new_melodies">

Some new melodies

</link>


</item>


			

<item id="li1011">
<link id="a1011" target-id="Play_or_file_the_melody">

Play or file the melody

</link>


</item>


			

<item id="li1012">
<link id="a1012" target-id="An_extremely_important_concept">

An extremely important concept

</link>


</item>



		

</list>


		

</item>


	

</list>


	

</item>



	

<item id="li1013">
<link id="a1013" target-id="Run_the_program">

Run the program

</link>


</item>



	

<item id="li1014">
<link id="a1014" target-id="Miscellaneous">

Miscellaneous

</link>


</item>


	

<item id="li1015">
<link id="a1015" target-id="Complete_program_listing">

Complete program listings

</link>


</item>




</list>


	
	

</section>
<section id="h11001">
<title>
<emphasis id="Preface" effect="bold">

Preface

</emphasis>


</title>


	

<para id="p1000">
This module is part of a collection titled 

<emphasis id="strong1000" effect="bold">
Accessible 
	Objected-Oriented Programming Concepts for Blind Students using Java

</emphasis>
. 
	It demonstrates runtime polymorphism using an array of the abstract type
	

<emphasis id="strong1001" effect="bold">
AudioSignalGenerator02

</emphasis>
 populated with references to objects 
	of eight different subclasses of 

<emphasis id="strong1002" effect="bold">
AudioSignalGenerator02

</emphasis>
 in 
	a format that is accessible to blind students.

</para>


	

<section id="h21000">
<title>
<emphasis id="Viewing_tip" effect="bold">

Viewing tip

</emphasis>


</title>


	

<para id="p1001">
I recommend that you open another copy of this module in a separate 
browser window and use the following links to easily find the listings while you are reading about them.

</para>


	

<section id="h31000">
<title>
<emphasis id="Listings" effect="bold">

Listings

</emphasis>


</title>


	

<list id="ul1005" list-type="bulleted">

		

<item id="li1016">
<link id="a1016" target-id="Listing_1">

Listing 1

</link>

. Beginning of the class named MusicComposer08. 

</item>


		

<item id="li1017">
<link id="a1017" target-id="Listing_2">

Listing 2

</link>

. Create and populate an array holding references to audio objects. 

</item>


		

<item id="li1018">
<link id="a1018" target-id="Listing_3">

Listing 3

</link>

. Call the getMelody method on a subclass object selected at random. 

</item>


		

<item id="li1019">
<link id="a1019" target-id="Listing_4">

Listing 4

</link>

. Play or file the melody. 

</item>


		

<item id="li1020">
<link id="a1020" target-id="Listing_5">

Listing 5

</link>

. The class named AudioGraphSinusoidal.

</item>


		

<item id="li1021">
<link id="a1021" target-id="Listing_6">

Listing 6

</link>

. The class named AudioGraphSquareWave.

</item>


		

<item id="li1022">
<link id="a1022" target-id="Listing_7">

Listing 7

</link>

. The class named FMSweep.

</item>


		

<item id="li1023">
<link id="a1023" target-id="Listing_8">

Listing 8

</link>

. The class named MusicComposer08.

</item>


		

<item id="li1024">
<link id="a1024" target-id="Listing_9">

Listing 9

</link>

. The class named SquareWave.

</item>


		

<item id="li1025">
<link id="a1025" target-id="Listing_10">

Listing 10

</link>

. The class named StereoPingpong.

</item>


		

<item id="li1026">
<link id="a1026" target-id="Listing_11">

Listing 11

</link>

. The class named ToneMono.

</item>


		

<item id="li1027">
<link id="a1027" target-id="Listing_12">

Listing 12

</link>

. The class named TonesStereo.

</item>


		

<item id="li1028">
<link id="a1028" target-id="Listing_13">

Listing 13

</link>

. The class named WhiteNoise.

</item>


		

<item id="li1029">
<link id="a1029" target-id="Listing_14">

Listing 14

</link>

. The class named AudioFormatParameters01.

</item>


		

<item id="li1030">
<link id="a1030" target-id="Listing_15">

Listing 15

</link>

. The class named AudioPlayOrFile01.

</item>


		

<item id="li1031">
<link id="a1031" target-id="Listing_16">

Listing 16

</link>

. The class named AudioSignalGenerator02.

</item>


	

</list>


	

</section>
</section>
</section>
<section id="h11002">
<title>
<emphasis id="General_background_information" effect="bold">

General 
	background information

</emphasis>


</title>




<para id="p1002">
We have reached a plateau of sorts in our study of Java sound. This and 
previous modules have produced hard-coded sounds. Future modules will be more 
flexible. For example, one future module will simulate a player piano. It will accept 
information about a melody as input data at runtime and will tailor the sound based on that information. For 
example, in future modules, you will learn to write a program to produce sounds 
like 

<link id="a1032" url="Greensleeves.au">

Greensleeves

</link>

 and


<link id="a1033" url="MaryHadALittleLamb.au">

MaryHadALittlelamb

</link>

.

</para>




<para id="p1003">
But I am getting ahead of myself. In previous modules, you have learned:

</para>




<list id="ul1006" list-type="bulleted">

	

<item id="li1032">
A little about the physical characteristics of sound.

</item>


	

<item id="li1033">
How to produce white or pink noise.

</item>


	

<item id="li1034">
How to produce square wave sound.

</item>


	

<item id="li1035">
How to produce a pure sinusoidal tone.

</item>


	

<item id="li1036">
How to produce an audio graph of a sinusoid.

</item>




</list>




<para id="p1004">
In this module, you will learn how to produce a few more types of sounds:

</para>




<list id="ul1007" list-type="bulleted">

	

<item id="li1037">
An audio graph for a square wave.

</item>


	

<item id="li1038">
A frequency-modulated sweep in stereo.

</item>


	

<item id="li1039">
A stereo ping pong effect.

</item>


	

<item id="li1040">
A pair of pure tones of different frequencies in stereo.

</item>




</list>




<para id="p1005">
More importantly, you will learn how to bring all of this knowledge together 
to demonstrate runtime polymorphism using sound.

</para>




<para id="p1006">
This program requires access to the following classes:

</para>




<list id="ul1008" list-type="bulleted">

	

<item id="li1041">
AudioGraphSinusoidal


</item>


	

<item id="li1042">
AudioGraphSquareWave


</item>


	

<item id="li1043">
FMSweep 

</item>


	

<item id="li1044">
MusicComposer08

</item>


	

<item id="li1045">
SquareWave


</item>


	

<item id="li1046">
StereoPingpong


</item>


	

<item id="li1047">
ToneMono 

</item>


	

<item id="li1048">
TonesStereo 

</item>


	

<item id="li1049">
WhiteNoise

</item>


	

<item id="li1050">
AudioFormatParameters01


</item>


	

<item id="li1051">
AudioPlayOrFile01


</item>


	

<item id="li1052">
AudioSignalGenerator02

</item>




</list>




<para id="p1007">
You will find source code for all of these classes in 

<link id="a1034" target-id="Listing_5">

Listing 5

</link>

 through 


<link id="a1035" target-id="Listing_16">

Listing 16

</link>

.

</para>




<para id="p1008">
You are already familiar with some of these classes because they were used in 
earlier modules.

</para>




<para id="p1009">
The driver class for this program is the class named 

<emphasis id="strong1003" effect="bold">
MusicComposer08

</emphasis>
. 
That is the only one of the twelve classes that I will discuss in detail. I will 
leave it as an exercise for the students at this point to study and understand 
the remaining eleven classes.

</para>


	
	

</section>
<section id="h11003">
<title>
<emphasis id="Discussion_and_sample_code" effect="bold">

Discussion and sample code

</emphasis>


</title>


	

<section id="h21001">
<title>
<emphasis id="The_class_named_MusicComposer08" effect="bold">

The class named MusicComposer08

</emphasis>


</title>




<para id="p1010">
The purpose of this program is to demonstrate 

<emphasis id="em1000" effect="italics">
late binding

</emphasis>
 and 

<emphasis id="em1001" effect="italics">
runtime 
polymorphism

</emphasis>
. This is accomplished by using an array
of the abstract type 

<emphasis id="strong1004" effect="bold">
AudioSignalGenerator02

</emphasis>
 populated with references to 
objects of the 

<emphasis id="following_eight_classes" effect="bold">

following eight classes

</emphasis>

: 

</para>




<list id="ul1009" list-type="bulleted">

	

<item id="li1053">
AudioGraphSinusoidal


</item>


	

<item id="li1054">
AudioGraphSquareWave 

</item>


	

<item id="li1055">
FMSweep 

</item>


	

<item id="li1056">
SquareWave


</item>


	

<item id="li1057">
StereoPingpong


</item>


	

<item id="li1058">
ToneMono 

</item>


	

<item id="li1059">
TonesStereo 

</item>


	

<item id="li1060">
WhiteNoise



</item>




</list>




<para id="p1011">
Each of the classes listed 

<link id="a1036" target-id="following_eight_classes">

above

</link>

 extends the abstract class named 


<emphasis id="strong1005" effect="bold">
AudioSignalGenerator02

</emphasis>
 and overrides the inherited abstract method named 


<emphasis id="strong1006" effect="bold">
getMelody

</emphasis>
.



</para>




<para id="p1012">
After the array is populated, a random number generator is used to get a 
random index into the array. The 

<emphasis id="strong1007" effect="bold">
getMelody

</emphasis>
 method is called on the reference 
pointed to by the random index. This causes the sound created by that particular audio 
object to be played or filed. 

</para>




<para id="p1013">
This is an example of late binding and runtime polymorphism because the 
compiler cannot possibly know the value of the random index when the program 
is compiled.



</para>




<para id="p1014">
As in previous modules, the sound can be played immediately or can be saved in an audio file of 
type AU for playback later. You should be able to play the audio file with any
standard media player that can handle the AU file type.



</para>




<para id="p1015">
The program also requires access to the following classes:


</para>




<list id="ul1010" list-type="bulleted">

	

<item id="li1061">
AudioFormatParameters01


</item>


	

<item id="li1062">
AudioPlayOrFile01


</item>


	

<item id="li1063">
AudioSignalGenerator02

</item>




</list>




<section id="h31001">
<title>
<emphasis id="Beginning_of_the_class_named_MusicComposer08" effect="bold">

Beginning of the 
class named MusicComposer08

</emphasis>


</title>




<para id="p1016">
<link id="a1037" target-id="Listing_1">

Listing 1

</link>

 shows the beginning of the class named 


<emphasis id="strong1008" effect="bold">
MusicComposer08

</emphasis>
. The code in 


<link id="a1038" target-id="Listing_1">

Listing 1

</link>

 is essentially the same as code that I have explained in several previous 
modules. Therefore, no further discussion of the code in 

<link id="a1039" target-id="Listing_1">

Listing 1

</link>

 
will be provided in this module.

</para>


	
	

<table id="table1000" summary="This is a table." pgwide="630">
<tgroup cols="1">


		

<thead id="thead1000">

			

<row id="tr1000">

				

<entry id="th1000">
<emphasis id="Listing_1" effect="bold">

Listing 1

</emphasis>

. Beginning of the class 
				named MusicComposer08.


</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1000">

			

<row id="tr1001">

				

<entry id="td1000">



<code id="pre1000" display="block">
import java.util.Random;

public class MusicComposer08{
  //Instantiate an object containing audio format parameters with predefined
  // values. They may be modified by the signal generator at runtime. Values
  // allowed by Java SDK 1.4.1 are shown in comments in the class definition.
  AudioFormatParameters01 audioParams = new AudioFormatParameters01();
  
  //A buffer to hold the audio data that will be played or filed.
  byte[] melody;
  
  //A place to store the incoming args array.
  String[] args; 
  //-------------------------------------------------------------------------//

  //Command-line parameter (only one parameter is needed)
  //If "play", the sound will be played immediately. Otherwise, the string will
  // be used as a filename for an audio file of type AU. In the latter case,
  // it must be a string that would be valid as a file name for the operating
  // system in use.  
  public static void main(String[] args){
    //Instantiate a new object of this class.
    new MusicComposer08(args);
  }//end main
  //-------------------------------------------------------------------------//
  
  public MusicComposer08(String[] args){//constructor
    //Save the args array.
    this.args = args;
    
    //Create default args data if no args data is provided on the command line.
    if(args.length == 0){
      this.args = new String[1];
      this.args[0] = "play";//Play the melody immediately
    }//end if
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

</section>
<section id="h31002">
<title>

	

<emphasis id="Create_and_populate_an_array_holding_references_to_audio_objects" effect="bold">


	Create and populate an array holding references to audio objects

</emphasis>


</title>




<para id="p1017">
<link id="a1040" target-id="Listing_2">

Listing 2

</link>

 begins by creating an array capable of holding references to eight audio objects instantiated from subclasses of the


<emphasis id="strong1009" effect="bold">
AudioSignalGenerator02

</emphasis>
 class. Note that the type of each 
element in this array is


<emphasis id="strong1010" effect="bold">
AudioSignalGenerator02

</emphasis>
.

</para>




<para id="p1018">
Then 

<link id="a1041" target-id="Listing_2">

Listing 2

</link>

 populates the array elements with references to eight different audio 
objects instantiated from those classes. Even though an object may be 
instantiated from the class named 

<emphasis id="strong1011" effect="bold">
FMSweep

</emphasis>
, for example, that 
object's reference is being stored as type 

<emphasis id="strong1012" effect="bold">
AudioSignalGenerator02

</emphasis>
.

</para>




	

<table id="table1001" summary="This is a table." pgwide="630">
<tgroup cols="1">


		

<thead id="thead1001">

			

<row id="tr1002">

				

<entry id="th1001">
<emphasis id="Listing_2" effect="bold">

Listing 2

</emphasis>

. Create and populate an 
				array holding references to audio objects.


</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1001">

			

<row id="tr1003">

				

<entry id="td1001">



<code id="pre1001" display="block">
    AudioSignalGenerator02[] audioObjects = new AudioSignalGenerator02[8];
    
    audioObjects[0] = new AudioGraphSinusoidal(audioParams,this.args,melody);
    audioObjects[1] = new AudioGraphSquareWave(audioParams,this.args,melody);
    audioObjects[2] = new FMSweep(audioParams,this.args,melody);
    audioObjects[3] = new SquareWave(audioParams,this.args,melody);
    audioObjects[4] = new StereoPingpong(audioParams,this.args,melody);
    audioObjects[5] = new ToneMono(audioParams,this.args,melody);
    audioObjects[6] = new TonesStereo(audioParams,this.args,melody);
    audioObjects[7] = new WhiteNoise(audioParams,this.args,melody);
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

</section>
<section id="h31003">
<title>
<emphasis id="Override_an_inherited_abstract_method" effect="bold">

Override an inherited 
	abstract method

</emphasis>


</title>




<para id="p1019">
The abstract class named 

<emphasis id="strong1013" effect="bold">
AudioSignalGenerator02

</emphasis>
 declares an 
abstract method named 

<emphasis id="strong1014" effect="bold">
getMelody

</emphasis>
. Each subclass of the abstract 
class must define a concrete version of 

<emphasis id="em1002" effect="italics">
(override)

</emphasis>
 the inherited 
abstract method or the subclass itself be declared abstract.

</para>




<para id="p1020">
All eight of the subclasses listed in 

<link id="a1042" target-id="Listing_2">

Listing 2

</link>

 override the 

<emphasis id="strong1015" effect="bold">

getMelody

</emphasis>
 method. The behavior of each overridden version of the method 
is significantly different from one class to the next.

</para>




<para id="p1021">
When the 

<emphasis id="strong1016" effect="bold">
getMelody

</emphasis>
 method is called on a reference to a 
subclass object that is stored as the superclass type, the resulting behavior is 
that of the subclass method and not that of the superclass method. That is 
runtime polymorphism.

</para>




</section>
<section id="h31004">
<title>
<emphasis id="Call_the_getMelody_method_on_a_subclass_object_selected_at_random" effect="bold">


Call the getMelody method on a subclass object selected at random

</emphasis>


</title>




<para id="p1022">
<link id="a1043" target-id="Listing_3">

Listing 3

</link>

 selects a reference to an audio object at random and calls the 

<emphasis id="strong1017" effect="bold">
getMelody

</emphasis>
 
method on the object. As in previous modules, the reference to the 

<emphasis id="strong1018" effect="bold">
byte

</emphasis>
 
array returned by the method is saved in the


<emphasis id="strong1019" effect="bold">
byte[]

</emphasis>
 variable named 

<emphasis id="strong1020" effect="bold">
melody

</emphasis>
. Unlike before, 
however, at this point, we don't know what melody was saved there. We only know that 
it will be one of eight possible melodies and we won't know which one until we 
actually play the melody. 

<emphasis id="em1003" effect="italics">
(At least that would be true if the code in


<link id="a1044" target-id="Listing_3">

Listing 3

</link>

 didn't access and print the type of the 
object pointed to by the random index.)

</emphasis>
</para>




	

<table id="table1002" summary="This is a table." pgwide="630">
<tgroup cols="1">


		

<thead id="thead1002">

			

<row id="tr1004">

				

<entry id="th1002">
<emphasis id="Listing_3" effect="bold">

Listing 3

</emphasis>

. Call the getMelody method 
				on a subclass object selected at random.


</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1002">

			

<row id="tr1005">

				

<entry id="td1002">



<code id="pre1002" display="block">
    Random randomGenerator = new Random();
    int randomIndex = randomGenerator.nextInt(8);
    System.out.println("randomIndex = " + randomIndex);
    System.out.println(audioObjects[randomIndex].getClass());
    
    melody = audioObjects[randomIndex].getMelody();
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

</section>
<section id="h31005">
<title>
<emphasis id="Some_new_melodies" effect="bold">

Some new melodies

</emphasis>


</title>




<para id="p1023">
The following melodies are new to this module:

</para>




<list id="ul1011" list-type="bulleted">

	

<item id="li1064">
<link id="a1045" url="AudioGraphSquareWave.au">

AudioGraphSquareWave

</link>


</item>


	

<item id="li1065">
<link id="a1046" url="FMSweep.au">

FMSweep

</link>


</item>


	

<item id="li1066">
<link id="a1047" url="StereoPingpong.au">

StereoPingpong

</link>


</item>


	

<item id="li1067">
<link id="a1048" url="TonesStereo.au">

TonesStereo

</link>


</item>




</list>




<para id="p1024">
You will find listings of the source code used to create these melodies later in this module.

</para>




</section>
<section id="h31006">
<title>
<emphasis id="Play_or_file_the_melody" effect="bold">

Play or file the melody

</emphasis>


</title>




<para id="p1025">
The code in 

<link id="a1049" target-id="Listing_4">

Listing 4

</link>

 uses the standard procedure to either play or file the


<emphasis id="strong1021" effect="bold">
melody

</emphasis>
 that was created in 

<link id="a1050" target-id="Listing_3">

Listing 3

</link>

.

</para>




	

<table id="table1003" summary="This is a table." pgwide="630">
<tgroup cols="1">


		

<thead id="thead1003">

			

<row id="tr1006">

				

<entry id="th1003">
<emphasis id="Listing_4" effect="bold">

Listing 4

</emphasis>

. Play or file the melody.


</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1003">

			

<row id="tr1007">

				

<entry id="td1003">



<code id="pre1003" display="block">
    new AudioPlayOrFile01(audioParams,melody,this.args[0]).playOrFileData();

  }//end constructor
  //-------------------------------------------------------------------------//
}//end class MusicComposer08.java
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

</section>
<section id="h31007">
<title>
<emphasis id="An_extremely_important_concept" effect="bold">

An extremely important concept

</emphasis>


</title>




<para id="p1026">
While this may seem like a rather innocuous result, runtime polymorphism is 
an extremely important concept in object-oriented programming. One of the 
important applications of runtime polymorphism is the 

<emphasis id="em1004" effect="italics">
Java Collections 
Framework

</emphasis>
. A series of accessible modules that explain the framework begins with 


<link id="a1051" url="http://cnx.org/contents/05a3d262-597c-46a0-8d6a-ab4ceee293dd">




<emphasis id="em1005" effect="italics">
Java4010

</emphasis>
</link>


<emphasis id="em1006" effect="italics">
: Getting Started with Java Collections

</emphasis>
.

</para>




</section>
</section>
</section>
<section id="h11004">
<title>
<emphasis id="Run_the_program" effect="bold">

Run the program

</emphasis>


</title>





<para id="p1027">
I encourage you to copy the code from 

<link id="a1052" target-id="Listing_5">

Listing 5

</link>

 through 

<link id="a1053" target-id="Listing_16">

Listing 16

</link>

. Compile the code and 
execute it. Experiment with the code, 
making changes, and observing the results of your changes. Make certain that you 
can explain why your changes behave as they do.

</para>


	

</section>
<section id="h11005">
<title>
<emphasis id="Miscellaneous" effect="bold">

Miscellaneous

</emphasis>


</title>


	

<para id="p1028">
This section contains a variety of miscellaneous information.

</para>





	

<note id="note1000" type="">


		


			


				

<emphasis id="strong1022" effect="bold">
Housekeeping material

</emphasis>

				

<list id="ul1012" list-type="bulleted">

					

<item id="li1068">
Module name: Jbs2050-Runtime Polymorphism with Java 
					Sound 

</item>


					

<item id="li1069">
File: Jbs2050.htm


</item>


					

<item id="li1070">
Published: 08/27/14

</item>


					

<item id="li1071">
Revised: 09/29/15

</item>


				

</list>


				

</note>

			


		



	






	

<note id="note1001" type="">


		


			


				

<emphasis id="strong1023" effect="bold">
Disclaimers:

</emphasis>
<para id="p1029">
<emphasis id="strong1024" effect="bold">
Financial

</emphasis>
: 
				Although the 

<emphasis id="strong1025" effect="bold">
OpenStax CNX

</emphasis>
 site makes it 
				possible for you to download a PDF file for the collection that 
				contains this module at no charge, and also makes it possible 
				for you to purchase a pre-printed version of the PDF file, you 
				should be aware that some of the HTML elements in this module 
				may not translate well into PDF.

</para>


				

<para id="p1030">
You also need to know that Prof. Baldwin receives no 
				financial compensation from 

<emphasis id="strong1026" effect="bold">
OpenStax CNX 

</emphasis>
even 
				if you purchase the PDF version of the collection.

</para>


				

<para id="p1031">
In the past, unknown individuals have copied Prof. Baldwin's 
				modules from cnx.org, converted them to Kindle books, and placed 
				them for sale on Amazon.com showing Prof. Baldwin as the author. 
				Prof. Baldwin neither receives compensation for those sales nor 
				does he know who does receive compensation. If you purchase such 
				a book, please be aware that it is a copy of a collection that 
				is freely available on 

<emphasis id="strong1027" effect="bold">
OpenStax CNX

</emphasis>
 and that it 
				was made and published without the prior knowledge of Prof. 
				Baldwin.

</para>


				

<para id="p1032">
<emphasis id="strong1028" effect="bold">
Affiliation

</emphasis>
: Prof. Baldwin is a professor of 
				Computer Information Technology at Austin Community College in 
				Austin, TX. 

</para>


				

</note>

			


		



	





</section>
<section id="h11006">
<title>
<emphasis id="Complete_program_listing" effect="bold">

Complete program listings

</emphasis>


</title>




<para id="p1033">
Complete listing of the twelve classes required by the program discussed in 
this module are provided below.

</para>




	

<table id="table1004" summary="This is a table." pgwide="630">
<tgroup cols="1">


		

<thead id="thead1004">

			

<row id="tr1008">

				

<entry id="th1004">
<emphasis id="Listing_5" effect="bold">

Listing 5

</emphasis>

. The class named 
				AudioGraphSinusoidal.

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1004">

			

<row id="tr1009">

				

<entry id="td1004">



<code id="pre1004" display="block">

/*File AudioGraphSinusoidal.java
Copyright 2014, R.G.Baldwin
Revised 08/23/14

This class can be used to create an 8-second melody consisting of 32 pulses
at different frequencies.
******************************************************************************/

import java.io.*;
import java.nio.*;
import java.util.*;

public class AudioGraphSinusoidal extends AudioSignalGenerator02{
  
  public AudioGraphSinusoidal(AudioFormatParameters01 audioParams,
               String[] args,
               byte[] melody){
    super(audioParams,args,melody);
  }//end constructor
  //-------------------------------------------------------------------------//
  

  //This method returns a melody array that will play an 8-second melody
  // consisting of 32 pulses at different frequencies. The frequencies of the
  // pulses are centered on middle-C (261.63 Hz).
  
  //The frequency deviation from middle-C versus time is based on a sinusoidal
  // function with a frequency of 0.5 Hz. Each pulse represents one point on
  // a graph of the sinusoid. Pulses with frequencies at or above middle-C are
  // delivered to the left speaker. Pulses with frequencies below middle-C are
  // delivered to the right speaker.

  //The audio output can be thought of as an audio representation of a graph
  // of a sinusoid. Pulses with frequencies above middle-C represent points
  // on the positive lobe of the sinusoid. Increasing pitch represents
  // increasing amplitude on the graph of the sinusoid. Pulses with
  // frequencies below middle-C can be thought of as representing points on
  // the negative lobe of the sinusoid. In this case, decreasing pitch
  // represents points on the sinusoid that are further from the horizontal
  // axis in the negative direction. Pulses with a frequency of middle-C can
  // be thought of as representing points on the horizontal axis with a value
  // of zero.

  //In order to eliminate pops and clicks caused by abrupt frequency changes
  // in the audio signal, the amplitude of each pulse is scaled by a
  // triangular (rooftop) function that has a value that is zero at both ends
  // and 1.0 in the center with a linear progression from the center to the
  // ends in both directions.

  //Four complete cycles of the 0.5 Hz sinusoid are represented by the 32
  // pulses in the 8-second melody.
  
  byte[] getMelody(){
    //Set channels to 2 for stereo overriding the default value of 1.
    audioParams.channels = 2;
    System.out.println("audioParams.channels = " + audioParams.channels);

    //Each channel requires two 8-bit bytes per 16-bit sample.
    int bytesPerSampPerChan = 2;
    
    //Override the default sampleRate of 16000.0F. Allowable sample rates
    // are 8000,11025,16000,22050, and 44100 samples per second.
    audioParams.sampleRate = 8000.0F;
    
    // Specify the length of the melody in seconds.
    double lengthInSeconds = 8.0;
    
    //Set the center frequency. Audio pulses will be generated above and
    // below this frequency to represent points on the graph of a 
    // sinusoidal function.
    double centerFreq = 261.63;//middle C
    
    //Create an output array of sufficient size to contain the melody at
    // "sampleRate" samples per second, "bytesPerSampPerChan" bytes per
    // sample per channel and "channels" channels.
    melody = new byte[(int)(lengthInSeconds*audioParams.sampleRate*
                                    bytesPerSampPerChan*audioParams.channels)];
    System.out.println("melody.length = " + melody.length);
    
    //Declare variables used to control the output volume on the left and
    // right speaker channels. These values will be used to cause pulses
    // representing negative values of the sinusoidal function to emit from
    // one speaker and pulses representing positive values to emit from
    // the other speaker.
    double gain = 0.0;
    double leftGain = 0.0;
    double rightGain = 0.0;

    //Declare a variable that is used to control the frequency of each pulse.
    double freq = 0.0;

    //Prepare a ByteBuffer for use
    byteBuffer = ByteBuffer.wrap(melody);

    //Compute the number of audio samples in the melody.
    int sampLength = (int)(lengthInSeconds*audioParams.sampleRate);

    //Set the length of each pulse in seconds and in samples.
    double pulseLengthInSec = 0.25;//in seconds
    int pulseLengthInSamples = (int)(pulseLengthInSec*audioParams.sampleRate);

    //Compute the audio sample values and deposit them in the output melody
    // array.
    for(int cnt = 0; cnt &lt; sampLength; cnt++){
      //Compute the time in seconds for this sample.
      double time = cnt/audioParams.sampleRate;
      
      if(cnt%pulseLengthInSamples == 0){
        //Time to create a new pulse at a different pitch. Compute the
        // frequency for the next pulse to represent a point on a sinusoidal
        // function of time. This section of code could easily be modified
        // to create audio graphs of many different functions.
        
        //Evaluate and scale the function
        double val = 0.35 * Math.sin(2*Math.PI*0.5*time);
        
        //Compute the frequency for the next pulse as a deviation from the
        // center frequency. For this scaled sinusoidal function, the Range
        // is from 0.65*centerFreq to 1.35*centerFreq or from 170.05 Hz
        // to 353.2 Hz.
        freq = (1+val)*centerFreq;

      }//end if

      //Deposit audio data in the melody for each channel. Scale the amplitude
      // of each pulse with a triangular scale factor (rooftop shape) to
      // minimize the undesirable pops and clicks that occur when there is an
      // abrupt change in the frequency from one pulse to the next. The 
      // following gain factor ranges from 0.0 at the ends to 1.0 in the
      // center of the pulse.
      gain = (cnt%pulseLengthInSamples)/(double)pulseLengthInSamples;
      if(gain &gt; 0.5){
        //Change to a negative slope.
        gain = (pulseLengthInSamples - 
                        cnt%pulseLengthInSamples)/(double)pulseLengthInSamples;
      }//end if
      
      //Set the final gain to a value that is compatible with 16-bit audio
      // data.
      gain = 8000*gain;

      //Switch the left and right channels on and off depending on the location
      // of the pulse frequency relative to the center frequency.
      if(freq &gt;= centerFreq){
        leftGain = gain;
        rightGain = 0;//switch off the right channel
      }else{
        rightGain = gain;
        leftGain = 0;//switch off the left channel
      }//
      
      //Compute scaled pulse values and deposit them into the melody.
      byteBuffer.putShort((short)(leftGain*Math.sin(2*Math.PI*freq*time)));
      byteBuffer.putShort((short)(rightGain*Math.sin(2*Math.PI*freq*time)));

    }//end for loop
    
    return melody;
  }//end method getMelody
  //-------------------------------------------------------------------------//

}//end class AudioGraphSinusoidal
//===========================================================================//
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>






<para id="p1034">
.....

</para>





	

<table id="table1005" summary="This is a table." pgwide="630">
<tgroup cols="1">


		

<thead id="thead1005">

			

<row id="tr1010">

				

<entry id="th1005">
<emphasis id="Listing_6" effect="bold">

Listing 6

</emphasis>

. The class named 
				AudioGraphSquareWave.

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1005">

			

<row id="tr1011">

				

<entry id="td1005">



<code id="pre1005" display="block">

/*File AudioGraphSquareWave.java
Copyright 2014, R.G.Baldwin
Revised 08/19/14

This class can be used to create an 8-second melody consisting of 32 pulses
at different frequencies.
******************************************************************************/

import java.io.*;
import java.nio.*;
import java.util.*;

public class AudioGraphSquareWave extends AudioSignalGenerator02{
  
  public AudioGraphSquareWave(AudioFormatParameters01 audioParams,
               String[] args,
               byte[] melody){
    super(audioParams,args,melody);
  }//end constructor
  //-------------------------------------------------------------------------//
  

  //This method returns a melody array that will play an 8-second melody
  // consisting of 32 pulses at two different frequencies. The two frequencies
  // are equidistant on either side of middle-C.
  
  //The frequency deviation from middle-C versus time is based on a square wave
  // function with a frequency of 0.5 Hz. That is, the function
  // switches between equal positive and negative values once per second
  // producing a periodic function where each cycle is two seconds
  // long.
  
  //Each pulse represents one point on
  // a graph of the square wave. Pulses with frequencies at or above
  // middle-C are delivered to the left speaker. Pulses with
  // frequencies below middle-C are delivered to the right speaker.
  // Middle-C is considered to represent the horizontal axis of the
  // graph with a value of zero.

  //The audio output can be thought of as an audio representation of a graph
  // of a square wave. Pulses with frequencies above middle-C represent points
  // on the positive lobe of the square wave. Increasing pitch represents
  // increasing amplitude on the graph of the square wave. Pulses with
  // frequencies below middle-C can be thought of as representing points on
  // the negative lobe of the square wave. In this case, decreasing pitch
  // represents points on the square wave that are further from the horizontal
  // axis in the negative direction.

  //In order to eliminate pops and clicks caused by abrupt frequency changes
  // in the audio signal, the amplitude of each pulse is scaled by a
  // triangular (rooftop) function that has a value that is zero at both ends
  // and 1.0 in the center with a linear progression from the center to the
  // ends in both directions.

  //Four complete cycles of the 0.5 Hz square wave are represented by the 32
  // pulses in the 8-second melody.
  
  byte[] getMelody(){
    //Set channels to 2 for stereo overriding the default value of 1.
    audioParams.channels = 2;
    System.out.println("audioParams.channels = " + audioParams.channels);

    //Each channel requires two 8-bit bytes per 16-bit sample.
    int bytesPerSampPerChan = 2;
    
    //Override the default sampleRate of 16000.0F. Allowable sample rates
    // are 8000,11025,16000,22050, and 44100 samples per second.
    audioParams.sampleRate = 8000.0F;
    
    // Specify the length of the melody in seconds.
    double lengthInSeconds = 8.0;
    
    //Set the center frequency.
    double centerFreq = 261.63;//middle C
    
    //Create an output array of sufficient size to contain the melody at
    // "sampleRate" samples per second, "bytesPerSampPerChan" bytes per
    // sample per channel and "channels" channels.
    melody = new byte[(int)(lengthInSeconds*audioParams.sampleRate*
                                    bytesPerSampPerChan*audioParams.channels)];
    System.out.println("melody.length = " + melody.length);
    
    //Declare variables used to control the output volume on the left and
    // right speaker channels.
    double gain = 0.0;
    double leftGain = 0.0;
    double rightGain = 0.0;

    //Declare the initial frequency deviation from center. To represent the
    // square wave, pulses will be played that are plus and minus this 
    // amount relative to the center frequency.
    double deviation = 75;
    
    //Specify the number of pulses in one-half cycle of the square wave.
    int halfCycle = 4;
    
    //Declare a variable that is used to control the frequency of each pulse.
    double freq = centerFreq + deviation;

    //Prepare a ByteBuffer for use
    byteBuffer = ByteBuffer.wrap(melody);

    //Compute the number of audio samples in the melody.
    int sampLength = (int)(lengthInSeconds*audioParams.sampleRate);

    //Set the length of each pulse in seconds and in samples.
    double pulseLengthInSec = 0.25;//in seconds
    int pulseLengthInSamples = (int)(pulseLengthInSec*audioParams.sampleRate);

    //Compute the audio sample values and deposit them in the output melody
    // array.
    for(int cnt = 0; cnt &lt; sampLength; cnt++){
      //Compute the time in seconds for this sample.
      double time = cnt/audioParams.sampleRate;
      
      if(cnt % (halfCycle * pulseLengthInSamples) == 0){
        //Switch to the other side of the center frequency.
        deviation = -deviation;
        freq = centerFreq + deviation;
      }//end if

      //Deposit audio data in the melody for each channel. Scale the amplitude
      // of each pulse with a triangular scale factor (rooftop shape) to
      // minimize the undesirable pops and clicks that occur when there is an
      // abrupt change in the frequency from one pulse to the next. The 
      // following gain factor ranges from 0.0 at the ends to 1.0 in the
      // center of the pulse.
      gain = (cnt%pulseLengthInSamples)/(double)pulseLengthInSamples;
      if(gain &gt; 0.5){
        //Change to a negative slope.
        gain = (pulseLengthInSamples - 
                        cnt%pulseLengthInSamples)/(double)pulseLengthInSamples;
      }//end if
      
      //Set the final gain to a value that is compatible with 16-bit audio
      // data.
      gain = 8000*gain;

      //Switch the left and right channels on and off depending on the location
      // of the pulse frequency relative to the center frequency.
      if(freq &gt;= centerFreq){
        leftGain = gain;
        rightGain = 0;//switch off the right channel
      }else{
        rightGain = gain;
        leftGain = 0;//switch off the left channel
      }//
      
      //Compute scaled pulse values and deposit them into the melody.
      byteBuffer.putShort((short)(leftGain*Math.sin(2*Math.PI*freq*time)));
      byteBuffer.putShort((short)(rightGain*Math.sin(2*Math.PI*freq*time)));

    }//end for loop
    
    return melody;
  }//end method getMelody
  //-------------------------------------------------------------------------//

}//end class AudioGraphSquareWave
//===========================================================================//
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>






<para id="p1035">
.....

</para>





	

<table id="table1006" summary="This is a table." pgwide="630">
<tgroup cols="1">


		

<thead id="thead1006">

			

<row id="tr1012">

				

<entry id="th1006">
<emphasis id="Listing_7" effect="bold">

Listing 7

</emphasis>

. The class named 
				FMSweep.

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1006">

			

<row id="tr1013">

				

<entry id="td1006">



<code id="pre1006" display="block">

/*File FMSweep.java
Copyright 2014, R.G.Baldwin
Revised 08/19/14

This class can be used to create an 8-second stereo melody consisting of a
linear frequency sweep with a linear pan between speakers.
******************************************************************************/

import java.io.*;
import java.nio.*;
import java.util.*;

public class FMSweep extends AudioSignalGenerator02{
  
  public FMSweep(AudioFormatParameters01 audioParams,
                 String[] args,
                 byte[] melody){
    super(audioParams,args,melody);
  }//end constructor
  //-------------------------------------------------------------------------//
  
  //This method returns an array that will play an 8-second melody consisting
  // of a linear frequency-modulated sweep from a low frequency of middle-C
  // to a high frequency that is one octave above middle-C. During the
  // frequency sweep, the sound pans linearly from the left speaker to the
  // right speaker.
  //
  byte[] getMelody(){

    //Set channels to 2 for stereo overriding the default value of 1.
    audioParams.channels = 2;
    System.out.println("audioParams.channels = " + audioParams.channels);

    //Each channel requires two 8-bit bytes per 16-bit sample.
    int bytesPerSampPerChan = 2;
    
    //Override the default sampleRate of 16000.0F. Allowable sample rates
    // are 8000,11025,16000,22050, and 44100 samples per second.
    audioParams.sampleRate = 8000.0F;
    
    // Specify the length of the melody in seconds.
    double lengthInSeconds = 8.0;
    
    //Set the low and high frequencies to cause the sweep to cover one full
    // octave.
    double lowFreq = 261.63;//middle C
    double highFreq = 2*lowFreq;

    //Create an output data array of sufficient size to contain the melody at
    // "sampleRate" samples per second, "bytesPerSampPerChan" bytes per
    // sample per channel and "channels" channels.
    melody = new byte[(int)(lengthInSeconds*audioParams.sampleRate*
                                    bytesPerSampPerChan*audioParams.channels)];
    System.out.println("melody.length = " + melody.length);
    
    //Set the overall gain to a value that is compatible with 16-bit audio
    // data.
    double gain = 8000.0;

    //Declare variables used to control the output volume on the left and
    // right speaker channels.
    double leftGain = 0.0;
    double rightGain = 0.0;

    //Declare a variable that is used to control the frequency.
    double freq = 0.0;

    //Prepare a ByteBuffer for use
    byteBuffer = ByteBuffer.wrap(melody);

    //Compute the number of audio samples in the melody.
    int sampLength = (int)(lengthInSeconds*audioParams.sampleRate);

    //Compute the audio sample values and deposit them in the output melody
    // array.
    for(int cnt = 0; cnt &lt; sampLength; cnt++){
      //Compute the time in seconds for this sample.
      double time = cnt/audioParams.sampleRate;
      
      //Compute the frequency for this iteration
      freq = lowFreq + (highFreq - lowFreq)*cnt/sampLength;

      //Adjust the left and right gain values to cause the sound to pan
      // linearly from the left speaker to the right speaker.
      rightGain = gain*1.0*cnt/sampLength;     
      leftGain = gain*1.0-rightGain;

      //Compute scaled values and deposit them into the melody.
      byteBuffer.putShort((short)(leftGain*Math.sin(2*Math.PI*freq*time)));
      byteBuffer.putShort((short)(rightGain*Math.sin(2*Math.PI*freq*time)));

    }//end for loop
    
    return melody;
  }//end method getMelody
  //-------------------------------------------------------------------------//

}//end class FMSweep
//===========================================================================//
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>






<para id="p1036">
.....

</para>





	

<table id="table1007" summary="This is a table." pgwide="630">
<tgroup cols="1">


		

<thead id="thead1007">

			

<row id="tr1014">

				

<entry id="th1007">
<emphasis id="Listing_8" effect="bold">

Listing 8

</emphasis>

. The class named 
				MusicComposer08.

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1007">

			

<row id="tr1015">

				

<entry id="td1007">



<code id="pre1007" display="block">

/*File MusicComposer08.java
Copyright 2014, R.G.Baldwin
Revised 08/24/14

This program demonstrates late binding and runtime polymorphism using an array
of the abstract type AudioSignalGenerator02 populated with references to 
objects of the following classes:

AudioGraphSinusoidal
AudioGraphSquareWave
FMSweep
SquareWave
StereoPingpong
ToneMono
TonesStereo
WhiteNoise

Each of the classes listed above extends the abstract class named 
AudioSignalGenerator02 and overrides the abstract method named getMelody.

After the array is populated, a random number generator is used to get a 
random index into the array. The getMelody method is called on the reference 
pointed to by the random index. This causes the sound created by that audio 
object to be played or filed. This is an example of late binding because the 
compiler cannot possibly know the value of the random index when the program 
is compiled.

The sound can be played immediately or can be saved in an audio file of 
type AU for playback later. You should be able to play the audio file with any
standard media player that can handle the AU file type.

The program also requires access to the following classes:
AudioFormatParameters01
AudioPlayOrFile01
AudioSignalGenerator02

Tested using JDK 1.8 under Win 7.
******************************************************************************/
import java.util.Random;

public class MusicComposer08{
  //Instantiate an object containing audio format parameters with predefined
  // values. They may be modified by the signal generator at runtime. Values
  // allowed by Java SDK 1.4.1 are shown in comments in the class definition.
  AudioFormatParameters01 audioParams = new AudioFormatParameters01();
  
  //A buffer to hold the audio data that will be played or filed.
  byte[] melody;
  
  //A place to store the incoming args array.
  String[] args; 
  //-------------------------------------------------------------------------//

  //Command-line parameter (only one parameter is needed)
  //If "play", the sound will be played immediately. Otherwise, the string will
  // be used as a filename for an audio file of type AU. In the latter case,
  // it must be a string that would be valid as a file name for the operating
  // system in use.  
  public static void main(String[] args){
    //Instantiate a new object of this class.
    new MusicComposer08(args);
  }//end main
  //-------------------------------------------------------------------------//
  
  public MusicComposer08(String[] args){//constructor
    //Save the args array.
    this.args = args;
    
    //Create default args data if no args data is provided on the command line.
    if(args.length == 0){
      this.args = new String[1];
      this.args[0] = "play";//Play the melody immediately
    }//end if
    
    //Create an array capable of holding references to eight audio objects
    // instantiated from subclasses of the AudioSignalGenerator02 class.
    AudioSignalGenerator02[] audioObjects = new AudioSignalGenerator02[8];
    
    //Populate the array elements with references to eight different
    // audio objects.
    audioObjects[0] = new AudioGraphSinusoidal(audioParams,this.args,melody);
    audioObjects[1] = new AudioGraphSquareWave(audioParams,this.args,melody);
    audioObjects[2] = new FMSweep(audioParams,this.args,melody);
    audioObjects[3] = new SquareWave(audioParams,this.args,melody);
    audioObjects[4] = new StereoPingpong(audioParams,this.args,melody);
    audioObjects[5] = new ToneMono(audioParams,this.args,melody);
    audioObjects[6] = new TonesStereo(audioParams,this.args,melody);
    audioObjects[7] = new WhiteNoise(audioParams,this.args,melody);
    
    //Select an audio object at random and call the getMelody method on
    // the object.
    Random randomGenerator = new Random();
    int randomIndex = randomGenerator.nextInt(8);
    System.out.println("randomIndex = " + randomIndex);
    System.out.println(audioObjects[randomIndex].getClass());
    
    melody = audioObjects[randomIndex].getMelody();

    //Play or file the audio data
    new AudioPlayOrFile01(audioParams,melody,this.args[0]).playOrFileData();

  }//end constructor
  //-------------------------------------------------------------------------//
}//end class MusicComposer08.java
//===========================================================================//
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>






<para id="p1037">
.....

</para>





	

<table id="table1008" summary="This is a table." pgwide="630">
<tgroup cols="1">


		

<thead id="thead1008">

			

<row id="tr1016">

				

<entry id="th1008">
<emphasis id="Listing_9" effect="bold">

Listing 9

</emphasis>

. The class named 
				SquareWave.

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1008">

			

<row id="tr1017">

				

<entry id="td1008">



<code id="pre1008" display="block">

/*File SquareWave.java
Copyright 2014, R.G.Baldwin
Revised 08/22/14

This class can be used to create a square wave with 1000 cycles per second
******************************************************************************/

import java.io.*;
import java.nio.*;
import java.util.*;

public class SquareWave extends AudioSignalGenerator02{
  
  public SquareWave(AudioFormatParameters01 audioParams,
               String[] args,
               byte[] melody){
    super(audioParams,args,melody);
  }//end constructor
  //-------------------------------------------------------------------------//
  

  //This method returns an array containing three seconds of a square wave
  // at 1000 cycles per second.

  byte[] getMelody(){
    //Recall that the default for channels is 1 for mono.
    System.out.println("audioParams.channels = " + audioParams.channels);
    
    //Each channel requires two 8-bit bytes per 16-bit sample.
    int bytesPerSampPerChan = 2;
    
    //Override the default sample rate. Allowable sample rates are 8000,11025,
    // 16000,22050,44100 samples per second.
    audioParams.sampleRate = 8000.0F;
    
    // Set the length of the melody in seconds
    double lengthInSeconds = 3.0;
    
    //Create an output data array sufficient to contain the melody
    // at "sampleRate" samples per second, "bytesPerSampPerChan" bytes per
    // sample per channel and "channels" channels.
    melody = new byte[(int)(lengthInSeconds*audioParams.sampleRate*
                                    bytesPerSampPerChan*audioParams.channels)];
    System.out.println("melody.length = " + melody.length);

    int val = 8000;//amplitude value of square wave
    byte byteLow = 0;
    byte byteHigh = 0;
    for(int cnt = 0;cnt &lt; melody.length; cnt+=2){

      //Change this value to change the fundamental frequency.
      //8 results in 1000 Hz
      //16 results in 500 Hz
      //32 results in 250 Hz, etc.
      if(cnt % 8 == 0){
        //Change sign
        val = -val;
      }//end if
      
      //Create two bytes that contain a 16-bit representation of the value.
      byteLow = (byte)val;//discard all but 8 lsb
      byteHigh = (byte)(val &gt;&gt; 8);//shift right 8 and discard all but 8 lsb
      
      //Deposit the bytes into the array
      melody[cnt] = byteHigh;
      melody[cnt + 1] = byteLow;

    }//end for loop    
    return melody;
  }//end method getMelody
  //-------------------------------------------------------------------------//

}//end class SquareWave 
//===========================================================================//
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>






<para id="p1038">
.....

</para>





	

<table id="table1009" summary="This is a table." pgwide="630">
<tgroup cols="1">


		

<thead id="thead1009">

			

<row id="tr1018">

				

<entry id="th1009">
<emphasis id="Listing_10" effect="bold">

Listing 10

</emphasis>

. The class named 
				StereoPingpong.

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1009">

			

<row id="tr1019">

				

<entry id="td1009">



<code id="pre1009" display="block">

/*File StereoPingpong.java
Copyright 2014, R.G.Baldwin
Revised 08/19/14

This class can be used to create an 4-second stereo melody that ping-pongs
back and forth between the left and right speakers.
******************************************************************************/

import java.io.*;
import java.nio.*;
import java.util.*;

public class StereoPingpong extends AudioSignalGenerator02{
  
  public StereoPingpong(AudioFormatParameters01 audioParams,
               String[] args,
               byte[] melody){
    super(audioParams,args,melody);
  }//end constructor
  //-------------------------------------------------------------------------//
  

  //This method returns an array that will play a four-second stereo sound
  // that ping-pongs back and forth between the left and right speakers. 
  // The tone emitted by the left speaker is at a frequency of middle-C. The
  // tone emitted by the right speaker is twice that frequency. The sound
  // switches between speakers four times per second.
  byte[] getMelody(){

    //Set channels to 2 for stereo overriding the default value of 1.
    audioParams.channels = 2;
    System.out.println("audioParams.channels = " + audioParams.channels);
    
    //Each channel requires two 8-bit bytes per 16-bit sample.
    int bytesPerSampPerChan = 2;
    
    //Override the default sampleRate of 16000.0F. Allowable sample rates
    // are 8000,11025,16000,22050, and 44100 samples per second.
    audioParams.sampleRate = 8000.0F;
    
    // Specify the length of the melody in seconds.
    double lengthInSeconds = 4.0;

    //Set the frequency for the left speaker.
    double freq = 261.63;//middle C
    
    //Create an output array of sufficient size to contain the melody at
    // "sampleRate" samples per second, "bytesPerSampPerChan" bytes per
    // sample per channel and "channels" channels.
    melody = new byte[(int)(lengthInSeconds*audioParams.sampleRate*
                                    bytesPerSampPerChan*audioParams.channels)];
    System.out.println("melody.length = " + melody.length);
    
    //Declare variables used to control the output volume on the left and
    // right speaker channels.
    double leftGain = 0.0;
    double rightGain = 8000.0;

    //Prepare a ByteBuffer for use
    byteBuffer = ByteBuffer.wrap(melody);

    //Compute the number of audio samples in the melody.
    int sampLength = (int)(lengthInSeconds*audioParams.sampleRate);

    //Set the length of each pulse in seconds and in samples.
    double pulseLengthInSec = 0.25;//in seconds
    int pulseLengthInSamples = (int)(pulseLengthInSec*audioParams.sampleRate);

    //Compute the audio sample values and deposit them in the output melody
    // array.
    for(int cnt = 0; cnt &lt; sampLength; cnt++){
      //Compute the time in seconds for this sample.
      double time = cnt/audioParams.sampleRate;
      
      if(cnt%pulseLengthInSamples == 0){
        //Swap gain values between channels
        double temp = leftGain;
        leftGain = rightGain;
        rightGain = temp;
      }//end if
      
      //Generate data for left speaker at middle-C
      double sinValue = Math.sin(2*Math.PI*(freq)*time);
      byteBuffer.putShort((short)(leftGain*sinValue));
      
      //Generate data for right speaker at twice the frequency of middle-C
      sinValue = Math.sin(2*Math.PI*(freq*2.0)*time);
      byteBuffer.putShort((short)(rightGain*sinValue));
      
    }//end for loop
    
    return melody;
  }//end method getMelody
  //-------------------------------------------------------------------------//

}//end class StereoPingpong
//===========================================================================//
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>






<para id="p1039">
.....

</para>





	

<table id="table1010" summary="This is a table." pgwide="630">
<tgroup cols="1">


		

<thead id="thead1010">

			

<row id="tr1020">

				

<entry id="th1010">
<emphasis id="Listing_11" effect="bold">

Listing 11

</emphasis>

. The class named 
				ToneMono.

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1010">

			

<row id="tr1021">

				

<entry id="td1010">



<code id="pre1010" display="block">

/*File ToneMono.java
Copyright 2014, R.G.Baldwin
Revised 08/22/14

This class that can be used to create a melody consisting of a single pure 
sinusoidal tone at 1000 Hz.

The class introduces the use of ByteBuffer.
******************************************************************************/

import java.io.*;
import java.nio.*;
import java.util.*;

public class ToneMono extends AudioSignalGenerator02{
  
  public ToneMono(AudioFormatParameters01 audioParams,
                     String[] args,
                     byte[] melody){
    super(audioParams,args,melody);
  }//end constructor
  //-------------------------------------------------------------------------//
  

  //This method generates a three-second pure sinusoidal tone. A 1000 Hz tone
  // is emitted with equal amplitude from the left and right speakers. It is
  // interesting to compare this sound with the sound of a square wave with
  // the same fundamental frequency.

  byte[] getMelody(){
    //Recall that the default is channels=1 for monaural.
    System.out.println("audioParams.channels = " + audioParams.channels);
    
    //Each channel requires two 8-bit bytes per 16-bit sample.
    int bytesPerSampPerChan = 2;
    
    //Override the default sample rate. Allowable sample rates are 8000,11025,
    // 16000,22050,44100 samples per second.
    audioParams.sampleRate = 8000.0F;
    
    // Set the length of the melody in seconds
    double lengthInSeconds = 3.0;
    
    //Set the frequency of the tone.
    double freq = 1000.0;
    
    //Create an output data array sufficient to contain the tone
    // at "sampleRate" samples per second, "bytesPerSampPerChan" bytes per
    // sample per channel and "channels" channels.
    melody = new byte[(int)(lengthInSeconds*audioParams.sampleRate*
                                    bytesPerSampPerChan*audioParams.channels)];
    System.out.println("melody.length = " + melody.length);
    
    //Prepare a ByteBuffer for use
    byteBuffer = ByteBuffer.wrap(melody);

    //Compute the number of audio samples in the melody.
    int sampLength = (int)(lengthInSeconds*audioParams.sampleRate);
    
    //Compute the audio sample values and deposit them in the output array.
    for(int cnt = 0; cnt &lt; sampLength; cnt++){
      //Compute the time in seconds for this sample.
      double time = cnt/audioParams.sampleRate;

      //Deposit audio data for both channels in mono. 
      byteBuffer.putShort((short)(8000*Math.sin(2*Math.PI*freq*time)));

    }//end for loop
    
    return melody;
  }//end method getMelody
  //-------------------------------------------------------------------------//

}//end class ToneMono 
//===========================================================================//
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>






<para id="p1040">
.....

</para>






	

<table id="table1011" summary="This is a table." pgwide="630">
<tgroup cols="1">


		

<thead id="thead1011">

			

<row id="tr1022">

				

<entry id="th1011">
<emphasis id="Listing_12" effect="bold">

Listing 12

</emphasis>

. The class named 
				TonesStereo.

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1011">

			

<row id="tr1023">

				

<entry id="td1011">



<code id="pre1011" display="block">

/*File TonesStereo.java
Copyright 2014, R.G.Baldwin
Revised 08/19/14

This class that can be used to create a melody consisting of two tones at 
different frequencies emitted from the left and right stereo speakers.
******************************************************************************/

import java.io.*;
import java.nio.*;
import java.util.*;

public class TonesStereo extends AudioSignalGenerator02{
  
  public TonesStereo(AudioFormatParameters01 audioParams,
                     String[] args,
                     byte[] melody){
    super(audioParams,args,melody);
  }//end constructor
  //-------------------------------------------------------------------------//
  

  //This method generates a pair of three-second tones in stereo.

  //A 261.63 (middle-C) tone is emitted from the left speaker and a higher
  // frequency tone is emitted from the right speaker.

  byte[] getMelody(){
    //Set the audio parameters to stereo overriding the default value.
    audioParams.channels = 2;
    System.out.println("audioParams.channels = " + audioParams.channels);
    
    //Each channel requires two 8-bit bytes per 16-bit sample.
    int bytesPerSampPerChan = 2;
    
    //Override the default sample rate. Allowable sample rates are 8000,11025,
    // 16000,22050,44100 samples per second.
    audioParams.sampleRate = 8000.0F;
    
    // Set the length of the melody in seconds
    double lengthInSeconds = 3.0;
    
    //Set the primary tone frequency.
    double freq = 261.63;//middle C
    
    //Create an output data array sufficient to contain the tone
    // at "sampleRate" samples per second, "bytesPerSampPerChan" bytes per
    // sample per channel and "channels" channels.
    melody = new byte[(int)(lengthInSeconds*audioParams.sampleRate*
                                    bytesPerSampPerChan*audioParams.channels)];
    System.out.println("melody.length = " + melody.length);
    
    //Prepare a ByteBuffer for use
    byteBuffer = ByteBuffer.wrap(melody);

    //Compute the number of audio samples in the melody.
    int sampLength = (int)(lengthInSeconds*audioParams.sampleRate);
    
    //Compute the audio sample values and deposit them in the output array.
    for(int cnt = 0; cnt &lt; sampLength; cnt++){
      //Compute the time in seconds for this sample.
      double time = cnt/audioParams.sampleRate;

      //Deposit audio data for the first (left) channel 
      byteBuffer.putShort((short)(8000*Math.sin(2*Math.PI*freq*time)));
      
      //Deposit audio data at a different frequency in the second (right)
      // channel.
      byteBuffer.putShort((short)(8000*Math.sin(2*Math.PI*freq*time*2.2)));

    }//end for loop
    
    return melody;
  }//end method getMelody
  //-------------------------------------------------------------------------//

}//end class TonesStereo 
//===========================================================================//
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>






<para id="p1041">
.....

</para>






	

<table id="table1012" summary="This is a table." pgwide="630">
<tgroup cols="1">


		

<thead id="thead1012">

			

<row id="tr1024">

				

<entry id="th1012">
<emphasis id="Listing_13" effect="bold">

Listing 13

</emphasis>

. The class named 
				WhiteNoise.

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1012">

			

<row id="tr1025">

				

<entry id="td1012">



<code id="pre1012" display="block">

/*File WhiteNoise.java
Copyright 2014, R.G.Baldwin
Revised 08/19/14

This is a simple class that can be used to create "white noise"
******************************************************************************/

import java.io.*;
import java.nio.*;
import java.util.*;

public class WhiteNoise extends AudioSignalGenerator02{
  
  public WhiteNoise(AudioFormatParameters01 audioParams,
               String[] args,
               byte[] melody){
    super(audioParams,args,melody);
  }//end constructor
  //-------------------------------------------------------------------------//
  

  //This method returns an array containing three seconds of monaural
  // white noise.

  byte[] getMelody(){
    //Set the audio parameters to mono
    audioParams.channels = 1;//superfluous -- default value
    System.out.println("audioParams.channels = " + audioParams.channels);
    
    //Each channel requires two 8-bit bytes per 16-bit sample.
    int bytesPerSampPerChan = 2;
    
    //Override the default sample rate. Allowable sample rates are 8000,11025,
    // 16000,22050,44100 samples per second.
    audioParams.sampleRate = 8000.0F;
    
    // Set the length of the melody in seconds
    double lengthInSeconds = 3.0;
    
    //Create an output data array sufficient to contain the melody
    // at "sampleRate" samples per second, "bytesPerSampPerChan" bytes per
    // sample per channel and "channels" channels.
    melody = new byte[(int)(lengthInSeconds*audioParams.sampleRate*
                                    bytesPerSampPerChan*audioParams.channels)];
    System.out.println("melody.length = " + melody.length);

    Random generator = new Random(new Date().getTime());
    for(int cnt = 0;cnt &lt; melody.length; cnt++){
      melody[cnt] = (byte)generator.nextInt();
    }//end for loop    
    return melody;
  }//end method getMelody
  //-------------------------------------------------------------------------//

}//end class WhiteNoise 
//===========================================================================//
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>






<para id="p1042">
.....

</para>






	

<table id="table1013" summary="This is a table." pgwide="630">
<tgroup cols="1">


		

<thead id="thead1013">

			

<row id="tr1026">

				

<entry id="th1013">
<emphasis id="Listing_14" effect="bold">

Listing 14

</emphasis>

. The class named 
				AudioFormatParameters01.

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1013">

			

<row id="tr1027">

				

<entry id="td1013">



<code id="pre1013" display="block">
/*File AudioFormatParameters01.java
Copyright 2014, R.G.Baldwin
Revised 08/16/14
******************************************************************************/

public class AudioFormatParameters01{
  //The following are audio format parameters used by the Java audio system.
  // They may be modified by the signal generator at runtime.  Values allowed
  // by Java SDK 1.4.1 are shown in comments.
  public float sampleRate = 16000.0F;
  //Allowable 8000,11025,16000,22050,44100 samples per second
  public int sampleSizeInBits = 16;
  //Allowable 8,16
  public int channels = 1;
  //Allowable 1 for mono and 2 for stereo
  public boolean signed = true;
  //Allowable true,false
  public boolean bigEndian = true;
  //Allowable true,false
}//end class AudioFormatParameters01
//===========================================================================//
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>






<para id="p1043">
.....

</para>






	

<table id="table1014" summary="This is a table." pgwide="630">
<tgroup cols="1">


		

<thead id="thead1014">

			

<row id="tr1028">

				

<entry id="th1014">
<emphasis id="Listing_15" effect="bold">

Listing 15

</emphasis>

. The class named 
				AudioPlayOrFile01.

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1014">

			

<row id="tr1029">

				

<entry id="td1014">



<code id="pre1014" display="block">
/*File AudioPlayOrFile01.java
Copyright 2014, R.G.Baldwin
Revised 08/16/14
******************************************************************************/
import javax.sound.sampled.*;
import java.io.*;
import java.util.*;

public class AudioPlayOrFile01{
  //An object of this class is used to either play the sound in the array
  // named melody or to write it into an audio file of type AU.
  
  //The following are general instance variables used to create a
  // SourceDataLine object.
  AudioFormat audioFormat;
  AudioInputStream audioInputStream;
  SourceDataLine sourceDataLine;

  AudioFormatParameters01 audioParams;
  byte[] melody;
  String playOrFile;//"play" to play immediately or a fileName to write
                    // an output file of type AU.
  //-------------------------------------------------------------------------//
  
  public AudioPlayOrFile01(AudioFormatParameters01 audioParams,
                           byte[] melody,
                           String playOrFile){//constructor

    this.audioParams = audioParams;
    this.melody = melody;
    this.playOrFile = playOrFile;
  }//end constructor
  //-------------------------------------------------------------------------//

  //This method plays or files the synthetic audio data that has been generated
  // and saved in an array.
  void playOrFileData() {
    try{
      //Get an input stream on the byte array containing the data
      InputStream byteArrayInputStream = new ByteArrayInputStream(melody);

      //Get the required audio format
      audioFormat = new AudioFormat(audioParams.sampleRate,
                                    audioParams.sampleSizeInBits,
                                    audioParams.channels,
                                    audioParams.signed,
                                    audioParams.bigEndian);

      //Get an audio input stream from the ByteArrayInputStream
      audioInputStream = new AudioInputStream(
                                     byteArrayInputStream,
                                     audioFormat,
                                     melody.length/audioFormat.getFrameSize());

      //Get info on the required data line
      DataLine.Info dataLineInfo = new DataLine.Info(SourceDataLine.class,
                                                     audioFormat);

      //Get a SourceDataLine object
      sourceDataLine = (SourceDataLine)AudioSystem.getLine(dataLineInfo);
                                   
      //Decide whether to play the audio data immediately, or to write it
      // into an audio file of type AU based on the incoming parameter named
      // playOrFile.
      if(playOrFile.toUpperCase().equals("PLAY")){
        //Create a thread to play back the data and start it running.  It will
        // run until all the data has been played back
        new PlayAudioThread().start();
      }else{
        //Write the data to an output file with the name provided by the
        // incoming parameter named playOrFile.
        try{
          AudioSystem.write(audioInputStream,
                            AudioFileFormat.Type.AU,
                            new File(playOrFile + ".au"));
        }catch (Exception e) {
          e.printStackTrace();
          System.exit(0);
        }//end catch
      }//end else
    }catch (Exception e) {
      e.printStackTrace();
      System.exit(0);
    }//end catch
  }//end playOrFileData
//===========================================================================//

  //Inner class to play back the data that was saved.
  class PlayAudioThread extends Thread{
    //This is a working buffer used to transfer the data between the
    // AudioInputStream and the SourceDataLine.  The size is rather arbitrary.
    byte playBuffer[] = new byte[16384];
  
    public void run(){
      try{
        //Open and start the SourceDataLine
        sourceDataLine.open(audioFormat);
        sourceDataLine.start();
  
        int cnt;
        //Get beginning of elapsed time for playback
        long startTime = new Date().getTime();
  
        //Transfer the audio data to the speakers
        while((cnt = audioInputStream.read(
                                       playBuffer,0,playBuffer.length)) != -1){
          //Keep looping until the input read method returns -1 for empty
          // stream.
          if(cnt &gt; 0){
            //Write data to the internal buffer of the data line where it will
            // be delivered to the speakers in real time
            sourceDataLine.write(playBuffer, 0, cnt);
          }//end if
        }//end while
  
        //Block and wait for internal buffer of the SourceDataLine to become
        // empty.
        sourceDataLine.drain();
  
  
        //Get and display the elapsed time for the previous playback.
        int elapsedTime = (int)(new Date().getTime() - startTime);
        System.out.println("Elapsed time: " + elapsedTime);
  
        //Finish with the SourceDataLine
        sourceDataLine.stop();
        sourceDataLine.close();
      }catch (Exception e) {
        e.printStackTrace();
        System.exit(0);
      }//end catch
  
    }//end run
  }//end inner class PlayAudioThread
  //=========================================================================//
}//end AudioPlayOrFile01 class
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>






<para id="p1044">
.....

</para>






	

<table id="table1015" summary="This is a table." pgwide="630">
<tgroup cols="1">


		

<thead id="thead1015">

			

<row id="tr1030">

				

<entry id="th1015">
<emphasis id="Listing_16" effect="bold">

Listing 16

</emphasis>

. The class named 
				AudioSignalGenerator02.

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1015">

			

<row id="tr1031">

				

<entry id="td1015">



<code id="pre1015" display="block">

/*File AudioSignalGenerator02.java
Copyright 2014, R.G.Baldwin
Revised 08/19/14

This is an abstract class that serves as the base class for several other 
classes that can be used to create melodies of different types.
******************************************************************************/

import java.io.*;
import java.nio.*;
import java.util.*;

public abstract class AudioSignalGenerator02{
  
  //Note:  This class can only be used to generate signed 16-bit data.
  ByteBuffer byteBuffer;
  String[] args;
  byte[] melody;
  AudioFormatParameters01 audioParams;
  //-------------------------------------------------------------------------//
  
  //Constructor
  public AudioSignalGenerator02(AudioFormatParameters01 audioParams,
                                String[] args,
                                byte[] melody){
    this.audioParams = audioParams;
    this.args = args;
    this.melody = melody;
  }//end constructor
  //-------------------------------------------------------------------------//

  //The following abstract method must be overridden in a subclass for this
  // class to be of any value.
  abstract byte[] getMelody();
}//end AudioSignalGenerator02
//===========================================================================//
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>






<para id="p1045">
-end- 

</para>






</section>
</content>




</document>