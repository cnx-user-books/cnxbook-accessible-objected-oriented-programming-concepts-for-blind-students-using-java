<document xmlns="http://cnx.rice.edu/cnxml"> 
<title>Jbs2030-A Pure Sinusoidal Tone</title>
<metadata xmlns:md="http://cnx.rice.edu/mdml">
  <md:content-id>m50930</md:content-id>
  <md:title>Jbs2030-A Pure Sinusoidal Tone</md:title>
  <md:abstract>This module explains how to write a program that creates an audio output consisting of a pure sinusoidal tone at 1000 Hz in a format that is accessible to blind students. It also explains how to use the ByteBuffer class to populate an array of bytes with data of type short.</md:abstract>
  <md:uuid>86bf668e-8040-4d63-881b-e5de24b25122</md:uuid>
</metadata>

<content>
















<section id="h11000">
<title>
Table of Contents

</title>




<list id="ul1000" list-type="bulleted">

	

<item id="li1000">
<link id="a1000" target-id="Preface">

Preface

</link>


	

<list id="ul1001" list-type="bulleted">

		

<item id="li1001">
<link id="a1001" target-id="Viewing_tip">

Viewing tip

</link>


<list id="ul1002" list-type="bulleted">


			

<item id="li1002">
<link id="a1002" target-id="Listings">

Listings

</link>


</item>


		

</list>


		

</item>


	

</list>


	

</item>



	

<item id="li1003">
<link id="a1003" target-id="General_background_information">

General background information

</link>


<list id="ul1003" list-type="bulleted">

		

<item id="li1004">
<link id="a1004" target-id="A_square_wave">

A square wave

</link>


<list id="ul1004" list-type="bulleted">

			

<item id="li1005">
<link id="a1005" target-id="An_audio_graph_of_a_square_wave">

An audio graph of a square wave

</link>


</item>


		

</list>


		

</item>


		

<item id="li1006">
<link id="a1006" target-id="A_pure_sinusoidal_tone">

A pure sinusoidal tone

</link>


<list id="ul1005" list-type="bulleted">

			

<item id="li1007">
<link id="a1007" target-id="The_difference_explained">

The difference explained

</link>


</item>


			

<item id="li1008">
<link id="a1008" target-id="An_audio_graph_of_a_sinusoid">

An audio graph of a sinusoid

</link>


</item>


		

</list>


		

</item>


	

</list>


	

</item>


	

<item id="li1009">
<link id="a1009" target-id="Discussion_and_sample_code">

Discussion and sample code

</link>


<list id="ul1006" list-type="bulleted">

		

<item id="li1010">
<link id="a1010" target-id="Three_classes_are_unchanged">

Three classes are unchanged

</link>


</item>


		

<item id="li1011">
<link id="a1011" target-id="The_class_named_MusicComposer06">

The class named MusicComposer06

</link>


</item>


		

<item id="li1012">
<link id="a1012" target-id="The_class_named_ToneMono">

The class named ToneMono

</link>


<list id="ul1007" list-type="bulleted">

			

<item id="li1013">
<link id="a1013" target-id="Beginning_of_the_class_named_ToneMono">

Beginning of the class named ToneMono

</link>


</item>


			

<item id="li1014">
<link id="a1014" target-id="Beginning_of_the_getMelody_method">

Beginning of the getMelody method

</link>


</item>


			

<item id="li1015">
<link id="a1015" target-id="Required_audio_data_format">

Required audio data format

</link>


<list id="ul1008" list-type="bulleted">

				

<item id="li1016">
<link id="a1016" target-id="Monaural_channels__1">

Monaural, channels = 1

</link>


</item>


				

<item id="li1017">
<link id="a1017" target-id="Stereo_channels__2">

Stereo, channels = 2

</link>


</item>


			

</list>


			

</item>


			

<item id="li1018">
<link id="a1018" target-id="Decomposing_a_short_into_two_bytes_using_ByteBuffer">

Decomposing a short into two bytes using ByteBuffer

</link>


</item>


			

<item id="li1019">
<link id="a1019" target-id="Instantiate_and_prepare_a_ByteBuffer_object">

Instantiate and prepare a ByteBuffer object

</link>


</item>


			

<item id="li1020">
<link id="a1020" target-id="Why_use_a_ByteBuffer_object">

Why use a ByteBuffer object?

</link>


</item>


			

<item id="li1021">
<link id="a1021" target-id="Compute_and_deposit_audio_samples_in_melody_array">

Compute and deposit audio samples in melody array

</link>


</item>



		

</list>


		

</item>



	

</list>


	

</item>



	

<item id="li1022">
<link id="a1022" target-id="Run_the_program">

Run the program

</link>


</item>



	

<item id="li1023">
<link id="a1023" target-id="Miscellaneous">

Miscellaneous

</link>


</item>


	

<item id="li1024">
<link id="a1024" target-id="Complete_program_listing">

Complete program listings

</link>


</item>




</list>


	
	

</section>
<section id="h11001">
<title>
<emphasis id="Preface" effect="bold">

Preface

</emphasis>


</title>


	

<para id="p1000">
This module is part of a collection titled 

<emphasis id="strong1000" effect="bold">
Accessible 
	Objected-Oriented Programming Concepts for Blind Students using Java

</emphasis>
. 
	It explains how to write a program that creates an audio output consisting 
	of a pure sinusoidal tone at 1000 Hz in a format that is accessible to blind 
	students. It also explains how to use the 

<emphasis id="strong1001" effect="bold">
ByteBuffer

</emphasis>
 class 
	to populate an array of bytes with data of type 

<emphasis id="strong1002" effect="bold">
short

</emphasis>
.

</para>


	

<section id="h21000">
<title>
<emphasis id="Viewing_tip" effect="bold">

Viewing tip

</emphasis>


</title>


	

<para id="p1001">
I recommend that you open another copy of this module in a separate 
	browser window and use the following links to easily find the listings while you are reading about them.

</para>


	

<section id="h31000">
<title>
<emphasis id="Listings" effect="bold">

Listings

</emphasis>


</title>


	

<list id="ul1009" list-type="bulleted">

		

<item id="li1025">
<link id="a1025" target-id="Listing_1">

Listing 1

</link>

. Beginning of the class named ToneMono.

</item>


		

<item id="li1026">
<link id="a1026" target-id="Listing_2">

Listing 2

</link>

. Beginning of the getMelody method.

</item>


		

<item id="li1027">
<link id="a1027" target-id="Listing_3">

Listing 3

</link>

. Instantiate and prepare a ByteBuffer object. 

</item>


		

<item id="li1028">
<link id="a1028" target-id="Listing_4">

Listing 4

</link>

. Compute and deposit audio samples in melody array. 

</item>


		

<item id="li1029">
<link id="a1029" target-id="Listing_5">

Listing 5

</link>

. The class named AudioFormatParameters01.

</item>


		

<item id="li1030">
<link id="a1030" target-id="Listing_6">

Listing 6

</link>

. The class named AudioPlayOrFile01.

</item>


		

<item id="li1031">
<link id="a1031" target-id="Listing_7">

Listing 7

</link>

. The class named AudioSignalGenerator02.

</item>


		

<item id="li1032">
<link id="a1032" target-id="Listing_8">

Listing 8

</link>

. The class named MusicComposer06.

</item>


		

<item id="li1033">
<link id="a1033" target-id="Listing_9">

Listing 9

</link>

. The class named ToneMono.

</item>


	

</list>


	

</section>
</section>
</section>
<section id="h11002">
<title>
<emphasis id="General_background_information" effect="bold">

General 
	background information

</emphasis>


</title>




<section id="h21001">
<title>
<emphasis id="A_square_wave" effect="bold">

A square wave

</emphasis>


</title>




<para id="p1002">
In an earlier module, we wrote a program that causes the diaphragms on 
computer speakers to move back and forth by creating audio data based on a 
square wave. Click 

<link id="a1034" url="SquareWave.au">

SquareWave

</link>

 to hear 
a sample of a 1000 Hz square wave. 

<emphasis id="em1000" effect="italics">
(You should be able to play the audio 
file with any standard media player that can handle the AU file type. In case 
you are on the OpenStax site and you are unable to download the audio file, 
click the 

</emphasis>
<emphasis id="strong1003" effect="bold">
<emphasis id="em1001" effect="italics">
Legacy Site

</emphasis>
</emphasis>
<emphasis id="em1002" effect="italics">
 link at the top of this 
page to switch over to the same module on the Legacy site. You should be able to 
download the audio file from there.)

</emphasis>
</para>




<section id="h31001">
<title>
<emphasis id="An_audio_graph_of_a_square_wave" effect="bold">

An audio graph of a square wave

</emphasis>


</title>




<para id="p1003">
I explained the concept of an 

<emphasis id="em1003" effect="italics">
audio graph

</emphasis>
 in earlier modules. Click


<link id="a1035" url="AudioGraphSquareWave.au">


AudioGraphSquareWave

</link>

 to hear an audio representation of the graph of a 
square wave.

</para>




</section>
</section>
<section id="h21002">
<title>
<emphasis id="A_pure_sinusoidal_tone" effect="bold">

A pure sinusoidal tone

</emphasis>


</title>




<para id="p1004">
In this module, we will write a program that causes the diaphragms on 
computer speakers to move back and forth by creating audio data based on a 
sinusoidal function. Click 

<link id="a1036" url="ToneMono.au">

ToneMono

</link>

 to hear 
a sample of a 1000 Hz sinusoidal function. Compare this sound with the sound of 
a 

<link id="a1037" url="SquareWave.au">

SquareWave

</link>

 with the same fundamental frequency.

</para>




<section id="h31002">
<title>
<emphasis id="The_difference_explained" effect="bold">

The difference explained

</emphasis>


</title>




<para id="p1005">
Depending on the quality of your speakers and the sensitivity of your ears, 
you may be able to hear a hint of higher frequency components in the square wave 
sound. A sinusoid represents a single frequency. A square wave with the same 
fundamental frequency contains a component with the same frequency as the 
sinusoid. However, it also contains some higher-frequency harmonics at lower intensity levels. In 
other words, the spectrum of a square wave is not a single frequency. Instead, 
it has a large peak at the fundamental frequency plus smaller peaks at higher 
frequencies that are harmonically related to the fundamental frequency.

</para>




</section>
<section id="h31003">
<title>
<emphasis id="An_audio_graph_of_a_sinusoid" effect="bold">

An audio graph of a sinusoid

</emphasis>


</title>




<para id="p1006">
Click


<link id="a1038" url="AudioGraphSinusoidal.au">

AudioGraphSinusoidal

</link>

 to hear an audio representation of the graph of a 
sinusoid. Compare this with


<link id="a1039" url="AudioGraphSquareWave.au">


AudioGraphSquareWave

</link>

, which is an audio representation of the graph of a 
square wave.

</para>




<para id="p1007">
I will explain the code that I wrote to create these audio graphs in a future 
module. Once you understand that code, you should be able to write the code to 
create audio graphs of many different mathematical functions, such as sine, 
cosine, tangent, cotangent, secant, cosecant, parabola, hyperbola, exponentials, 
half circle, half ellipse, 
and many others. 

<emphasis id="em1004" effect="italics">
(See 

<link id="a1040" url="http://functions.wolfram.com/">


functions.wolfram.com

</link>

 for thousands of formulas of hundreds of functions.)

</emphasis>
</para>



	
	

</section>
</section>
</section>
<section id="h11003">
<title>
<emphasis id="Discussion_and_sample_code" effect="bold">

Discussion and sample code

</emphasis>


</title>


	

<para id="p1008">
<emphasis id="This_program_requires" effect="bold">

This program requires

</emphasis>

 the following 
	five classes:

</para>




<list id="ul1010" list-type="bulleted">

	

<item id="li1034">
AudioFormatParameters01 

<emphasis id="em1005" effect="italics">
(see
	

<link id="a1041" target-id="Listing_5">

Listing 5

</link>

)

</emphasis>
</item>


	

<item id="li1035">
AudioPlayOrFile01 

<emphasis id="em1006" effect="italics">
(see
	

<link id="a1042" target-id="Listing_6">

Listing 6

</link>

)

</emphasis>
</item>


	

<item id="li1036">
AudioSignalGenerator02 

<emphasis id="em1007" effect="italics">
(see
	

<link id="a1043" target-id="Listing_7">

Listing 7

</link>

)

</emphasis>
</item>


	

<item id="li1037">
MusicComposer06 

<emphasis id="em1008" effect="italics">
(see
	

<link id="a1044" target-id="Listing_8">

Listing 8

</link>

)

</emphasis>
</item>


	

<item id="li1038">
ToneMono 

<emphasis id="em1009" effect="italics">
(see 

<link id="a1045" target-id="Listing_9">

Listing 9

</link>

)

</emphasis>
</item>




</list>


	

<section id="h21003">
<title>
<emphasis id="Three_classes_are_unchanged" effect="bold">

Three classes are unchanged

</emphasis>


</title>




<para id="p1009">
I won't bore you by repeating the discussion from earlier modules. The first 
three classes in the


<link id="a1046" target-id="This_program_requires">


above list

</link>

 are completely unchanged from the module titled 

<emphasis id="em1010" effect="italics">
Jbs2010-Your 
First Sound Program

</emphasis>
. Therefore, I won't discuss them further in this 
module.

</para>


	

</section>
<section id="h21004">
<title>
<emphasis id="The_class_named_MusicComposer06" effect="bold">

The class named 
	MusicComposer06

</emphasis>


</title>




<para id="p1010">
The class named 

<emphasis id="strong1004" effect="bold">
MusicComposer06

</emphasis>
 differs from the previous 
version only in the following respects:

</para>




<list id="ul1011" list-type="bulleted">

	

<item id="li1039">
Changes in the explanatory comments.

</item>


	

<item id="li1040">
Replacement of the term 

<emphasis id="strong1005" effect="bold">
WhiteNoise

</emphasis>
 with the term
	

<emphasis id="strong1006" effect="bold">
ToneMono

</emphasis>
.

</item>


	

<item id="li1041">
Replacement of the term 

<emphasis id="strong1007" effect="bold">
whiteNoise

</emphasis>
 with the term
	

<emphasis id="strong1008" effect="bold">
toneMono

</emphasis>
.

</item>




</list>




<para id="p1011">
Therefore, I also won't discuss this class further in this module.

</para>


	

</section>
<section id="h21005">
<title>
<emphasis id="The_class_named_ToneMono" effect="bold">

The class named ToneMono

</emphasis>


</title>


	

<para id="p1012">
A complete listing of the class named 

<emphasis id="strong1009" effect="bold">
ToneMono

</emphasis>
 is 
	provided in
	

<link id="a1047" target-id="Listing_9">

Listing 9

</link>

. 
	I will break this class down and explain it in fragments.

</para>




<section id="h31004">
<title>
<emphasis id="Beginning_of_the_class_named_ToneMono" effect="bold">

Beginning of the class named 
ToneMono

</emphasis>


</title>


	

<para id="p1013">
The sound that you heard when you listened to the audio file named
	

<link id="a1048" url="ToneMono.au">

ToneMono

</link>

 was 
	produced by the 

<emphasis id="strong1010" effect="bold">
getMelody

</emphasis>
 method of the 

<emphasis id="strong1011" effect="bold">
ToneMono

</emphasis>
 
	class. The 

<emphasis id="strong1012" effect="bold">
ToneMono

</emphasis>
 class begins in
	

<link id="a1049" target-id="Listing_1">

Listing 1

</link>

 
	and the 

<emphasis id="strong1013" effect="bold">
getMelody

</emphasis>
 method begins in
	

<link id="a1050" target-id="Listing_2">

Listing 2

</link>

.

</para>




<para id="p1014">
The code in 


<link id="a1051" target-id="Listing_1">

Listing 1

</link>

 differs from the corresponding 

<emphasis id="strong1014" effect="bold">
WhiteNoise

</emphasis>
 code 
from the earlier module only with respect to the name of the class. Therefore, I 
won't discuss it further.

</para>




	

<table id="table1000" summary="This is a table." pgwide="630">
<tgroup cols="1">


		

<thead id="thead1000">

			

<row id="tr1000">

				

<entry id="th1000">
<emphasis id="Listing_1" effect="bold">

Listing 1

</emphasis>

. Beginning of the class named ToneMono.

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1000">

			

<row id="tr1001">

				

<entry id="td1000">



<code id="pre1000" display="block">
import java.io.*;
import java.nio.*;
import java.util.*;

public class ToneMono extends AudioSignalGenerator02{
  
  public ToneMono(AudioFormatParameters01 audioParams,
                     String[] args,
                     byte[] melody){
    super(audioParams,args,melody);
  }//end constructor
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

</section>
<section id="h31005">
<title>
<emphasis id="Beginning_of_the_getMelody_method" effect="bold">

Beginning of the getMelody 
	method

</emphasis>


</title>




<para id="p1015">
  This method returns an array containing three-seconds of a pure sinusoidal tone. 
When this array is processed, a 1000 Hz tone is emitted with equal amplitude from the left and right speakers. It is interesting to compare 


<link id="a1052" url="ToneMono.au">

this sound

</link>

 with the sound of a 

<link id="a1053" url="SquareWave.au">

square wave

</link>

 with the same fundamental frequency.

</para>




<para id="p1016">
<link id="a1054" target-id="Listing_2">

Listing 2

</link>

 
shows the beginning of the overridden 

<emphasis id="strong1015" effect="bold">
getMelody

</emphasis>
 method. 

<emphasis id="em1011" effect="italics">

(Recall that an abstract version of this method is inherited from the class 
named 

<emphasis id="strong1016" effect="bold">
AudioSignalGenerator02 

</emphasis>
-- see


<link id="a1055" target-id="Listing_7">

Listing 7

</link>

)

</emphasis>
</para>




<para id="p1017">
With one exception, the code in


<link id="a1056" target-id="Listing_2">

Listing 2

</link>

 is essentially the same as the corresponding 

<emphasis id="strong1017" effect="bold">
WhiteNoise

</emphasis>
 
code from the earlier module. The exception is the statement that declares a 
variable named 

<emphasis id="strong1018" effect="bold">
freq

</emphasis>
 and sets its value to 1000.0. As you will 
see later, the value stored in this variable establishes the frequency of the 
sinusoidal tone. Beyond that, I won't discuss the code in 

<link id="a1057" target-id="Listing_2">

Listing 2

</link>

 any further.

</para>




	

<table id="table1001" summary="This is a table." pgwide="630">
<tgroup cols="1">


		

<thead id="thead1001">

			

<row id="tr1002">

				

<entry id="th1001">
<emphasis id="Listing_2" effect="bold">

Listing 2

</emphasis>

. Beginning of the getMelody method.

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1001">

			

<row id="tr1003">

				

<entry id="td1001">



<code id="pre1001" display="block">
  byte[] getMelody(){
    //Recall that the default is channels=1 for monaural.
    System.out.println("audioParams.channels = " + audioParams.channels);
    
    //Each channel requires two 8-bit bytes per 16-bit sample.
    int bytesPerSampPerChan = 2;
    
    //Override the default sample rate. Allowable sample rates are 8000,11025,
    // 16000,22050,44100 samples per second.
    audioParams.sampleRate = 8000.0F;
    
    // Set the length of the melody in seconds
    double lengthInSeconds = 3.0;
    
    //Set the frequency of the tone.
    double freq = 1000.0;
    
    //Create an output data array sufficient to contain the tone
    // at "sampleRate" samples per second, "bytesPerSampPerChan" bytes per
    // sample per channel and "channels" channels.
    melody = new byte[(int)(lengthInSeconds*audioParams.sampleRate*
                                    bytesPerSampPerChan*audioParams.channels)];
    System.out.println("melody.length = " + melody.length);
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

</section>
<section id="h31006">
<title>
<emphasis id="Required_audio_data_format" effect="bold">

Required audio data format

</emphasis>


</title>




<para id="p1018">
I explained the required format of the audio data in the 

<emphasis id="strong1019" effect="bold">
melody

</emphasis>
 
array in an earlier module. I will repeat that explanation here for convenience.

</para>




<para id="p1019">
Given the values that we are using in the 

<emphasis id="strong1020" effect="bold">
AudioFormatParameters01

</emphasis>
 
object, the format requirements for monaural and stereo are shown below. 

<emphasis id="em1012" effect="italics">

(Note that in both cases, each audio value must be a signed 16-bit value 
decomposed into a pair of 8-bit bytes.)

</emphasis>
</para>




<section id="h41000">
<title>
<emphasis id="Monaural_channels__1" effect="bold">

Monaural, channels = 1

</emphasis>


</title>




<para id="p1020">
For mono, each successive pair of bytes in the array must contain one audio 
value. The element with the lower index must contain the most significant eight 
bits of the 16-bit audio value.

</para>




</section>
<section id="h41001">
<title>
<emphasis id="Stereo_channels__2" effect="bold">

Stereo, channels = 2

</emphasis>


</title>




<para id="p1021">
For stereo, alternating pairs of bytes must each contain one audio value in 
the same byte order as for mono. One pair of bytes is routed to the left speaker 
and the other pair of bytes is routed to the right speaker 

<emphasis id="em1013" effect="italics">
(almost)

</emphasis>
 
simultaneously.

</para>




<para id="p1022">
Within the four bytes, the pair with the lowest index is routed to the left 
speaker and the other pair is routed to the right speaker.

</para>


	

<para id="p1023">
I will also remind you that the code in the 

<emphasis id="strong1021" effect="bold">
SquareWave

</emphasis>
 
	class used bit shifting and casting to decompose the 

<emphasis id="strong1022" effect="bold">
short

</emphasis>
 
	value into a pair of 

<emphasis id="strong1023" effect="bold">
byte

</emphasis>
 values. We will accomplish that 
	in a different and somewhat simpler way in this module.

</para>




</section>
</section>
<section id="h31007">
<title>
<emphasis id="Decomposing_a_short_into_two_bytes_using_ByteBuffer" effect="bold">

Decomposing a 
short into two bytes using ByteBuffer

</emphasis>


</title>




<para id="p1024">
Recall that the abstract class named 

<emphasis id="strong1024" effect="bold">
AudioSignalGenerator02

</emphasis>



<emphasis id="em1014" effect="italics">
(see 

<link id="a1058" target-id="Listing_7">

Listing 7

</link>

)

</emphasis>
 declares an instance variable of type 

<emphasis id="strong1025" effect="bold">

ByteBuffer

</emphasis>
 named 

<emphasis id="strong1026" effect="bold">
byteBuffer

</emphasis>
. This variable is inherited into the 

<emphasis id="strong1027" effect="bold">
ToneMono

</emphasis>
 class and is available to the 

<emphasis id="strong1028" effect="bold">
getMelody

</emphasis>
 
method.

</para>




	

<para id="p1025">
I encourage you to go to the Java Standard Edition documentation and read 
	about the class named 

<emphasis id="strong1029" effect="bold">
ByteBuffer

</emphasis>
. 
	This is a very powerful class with a lot of capability.

</para>




<para id="p1026">
In this module, we will use an object of the 

<emphasis id="strong1030" effect="bold">
ByteBuffer

</emphasis>
 class to eliminate some of the complexity involved 
in decomposing a 

<emphasis id="strong1031" effect="bold">
short

</emphasis>
 audio value into a pair of 

<emphasis id="strong1032" effect="bold">
byte

</emphasis>
  values 
and depositing the two 

<emphasis id="strong1033" effect="bold">
byte

</emphasis>
 values in the 

<emphasis id="strong1034" effect="bold">
melody

</emphasis>
  array.

</para>




</section>
<section id="h31008">
<title>
<emphasis id="Instantiate_and_prepare_a_ByteBuffer_object" effect="bold">

Instantiate and prepare a ByteBuffer object

</emphasis>


</title>




<para id="p1027">
Using terminology from the Java SE documentation, the statement in 

<link id="a1059" target-id="Listing_3">

Listing 3

</link>

 
creates a 

<emphasis id="strong1035" effect="bold">
ByteBuffer

</emphasis>
 object and saves that object's reference 
in the inherited variable named 

<emphasis id="strong1036" effect="bold">
byteBuffer

</emphasis>
 by 

<emphasis id="em1015" effect="italics">
wrapping an existing


</emphasis>
 

<emphasis id="strong1037" effect="bold">
<emphasis id="em1016" effect="italics">
byte

</emphasis>
</emphasis>
<emphasis id="em1017" effect="italics">
 array (

</emphasis>
<emphasis id="strong1038" effect="bold">
<emphasis id="em1018" effect="italics">
melody

</emphasis>
</emphasis>
<emphasis id="em1019" effect="italics">
) into a buffer

</emphasis>
. 

</para>




	

<table id="table1002" summary="This is a table." pgwide="630">
<tgroup cols="1">


		

<thead id="thead1002">

			

<row id="tr1004">

				

<entry id="th1002">
<emphasis id="Listing_3" effect="bold">

Listing 3

</emphasis>

. Instantiate and prepare a 
				ByteBuffer object.


</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1002">

			

<row id="tr1005">

				

<entry id="td1002">



<code id="pre1002" display="block">
    byteBuffer = ByteBuffer.wrap(melody);</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>





</section>
<section id="h31009">
<title>
<emphasis id="Why_use_a_ByteBuffer_object" effect="bold">

Why use a ByteBuffer object

</emphasis>

?

</title>




<para id="p1028">
Normally the elements of a 

<emphasis id="strong1039" effect="bold">
byte

</emphasis>
 array can only be accessed 
using indexed square bracket 

<emphasis id="em1020" effect="italics">
([index])

</emphasis>
 notation. Wrapping the array in 
a 

<emphasis id="strong1040" effect="bold">
ByteBuffer

</emphasis>
 object makes it possible to access the elements in the array by calling methods that are defined in the 

<emphasis id="strong1041" effect="bold">
ByteBuffer

</emphasis>
 class. For example, 
the array can be populated from beginning to end using successive calls to the 
overloaded 

<emphasis id="strong1042" effect="bold">
put

</emphasis>
 
methods of the 

<emphasis id="strong1043" effect="bold">
ByteBuffer

</emphasis>
 class without regard for the actual index of the 
elements 

<emphasis id="em1021" effect="italics">
(provided that you don't try to exceed the length of the array)

</emphasis>
.

</para>




<para id="p1029">
Although it isn't obvious, this solves the problem of decomposing the 


<emphasis id="strong1044" effect="bold">
short

</emphasis>
 value into a pair of 

<emphasis id="strong1045" effect="bold">
byte

</emphasis>
 values and depositing them in the correct order 
in the melody 

<emphasis id="strong1046" effect="bold">
array

</emphasis>
. One of the methods of the 

<emphasis id="strong1047" effect="bold">
ByteBuffer

</emphasis>
 class 
is named 

<emphasis id="strong1048" effect="bold">
putShort

</emphasis>
. As you will see later, that method makes it 
possible to "put" a 

<emphasis id="strong1049" effect="bold">
short

</emphasis>
 value into our 

<emphasis id="strong1050" effect="bold">
ByteBuffer

</emphasis>
 object 


<emphasis id="em1022" effect="italics">
(and hence 
into our 

</emphasis>
 

<emphasis id="strong1051" effect="bold">
<emphasis id="em1023" effect="italics">
melody

</emphasis>
</emphasis>
<emphasis id="em1024" effect="italics">
 array)

</emphasis>
 with a single statement. The 

<emphasis id="strong1052" effect="bold">
putShort

</emphasis>
 
method will automatically decompose the 

<emphasis id="strong1053" effect="bold">
short

</emphasis>
 value into two 

<emphasis id="strong1054" effect="bold">
byte

</emphasis>
 
values and deposit them in the proper order in the array.

</para>




</section>
<section id="h31010">
<title>
<emphasis id="Compute_and_deposit_audio_samples_in_melody_array" effect="bold">

Compute and 
deposit audio samples in melody array

</emphasis>


</title>




<para id="p1030">
<link id="a1060" target-id="Listing_4">

Listing 4

</link>

 begins by computing the melody length in samples as the product of the 
length in seconds and the sampling rate in samples per second.

</para>




	

<table id="table1003" summary="This is a table." pgwide="630">
<tgroup cols="1">


		

<thead id="thead1003">

			

<row id="tr1006">

				

<entry id="th1003">
<emphasis id="Listing_4" effect="bold">

Listing 4

</emphasis>

. Compute and deposit audio 
				samples in melody array.


</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1003">

			

<row id="tr1007">

				

<entry id="td1003">



<code id="pre1003" display="block">
    //Compute the number of audio samples in the melody.
    int sampLength = (int)(lengthInSeconds*audioParams.sampleRate);
    
    //Compute the audio sample values and deposit them in the output array.
    for(int cnt = 0; cnt &lt; sampLength; cnt++){
      //Compute the time in seconds for this sample.
      double time = cnt/audioParams.sampleRate;

      //Deposit audio data for both channels in mono. 
      byteBuffer.putShort((short)(8000*Math.sin(2*Math.PI*freq*time)));

    }//end for loop
    
    return melody;
  }//end method getMelody
  //-------------------------------------------------------------------------//

}//end class ToneMono
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1031">
Then 

<link id="a1061" target-id="Listing_4">

Listing 4

</link>

 enters a 

<emphasis id="strong1055" effect="bold">
for

</emphasis>
 loop for the purpose of

</para>




<list id="ul1012" list-type="bulleted">

	

<item id="li1042">
Computing the time in seconds for the current sample.

</item>


	

<item id="li1043">
Computing the value of the 

<emphasis id="strong1056" effect="bold">
Math.sin

</emphasis>
 function for that 
	time.

</item>


	

<item id="li1044">
Scaling that value up by 8000 to attain a reasonable audio level.

</item>


	

<item id="li1045">
Casting that result to type 

<emphasis id="strong1057" effect="bold">
short

</emphasis>
.

</item>


	

<item id="li1046">
Using the 

<emphasis id="strong1058" effect="bold">
putShort

</emphasis>
 method of the 

<emphasis id="strong1059" effect="bold">
ByteBuffer

</emphasis>
 
	class discussed earlier to deposit the 

<emphasis id="strong1060" effect="bold">
short

</emphasis>
 value in the 
	next two bytes in the 

<emphasis id="strong1061" effect="bold">
melody

</emphasis>
 array in a single statement.

</item>




</list>




<para id="p1032">
If you go back and examine the code for this part of the 

<emphasis id="strong1062" effect="bold">
SquareWave

</emphasis>
 
program, you will see that the use of the 

<emphasis id="strong1063" effect="bold">
putShort

</emphasis>
 method of 
the 

<emphasis id="strong1064" effect="bold">
ByteBuffer

</emphasis>
 class has simplified things considerably.

</para>




<para id="p1033">
Finally the code in 

<link id="a1062" target-id="Listing_4">

Listing 4

</link>


</para>




<list id="ul1013" list-type="bulleted">

	

<item id="li1047">
Returns a reference to the 

<emphasis id="strong1065" effect="bold">
melody

</emphasis>
 array so that it can 
	be processed by the code in the object of the 

<emphasis id="strong1066" effect="bold">
MusicComposer06

</emphasis>
 
	class.

</item>


	

<item id="li1048">
Signals the end of the 

<emphasis id="strong1067" effect="bold">
getMelody

</emphasis>
 method of the 

<emphasis id="strong1068" effect="bold">

	ToneMono

</emphasis>
 class.

</item>


	

<item id="li1049">
Signals the end of the 

<emphasis id="strong1069" effect="bold">
ToneMono

</emphasis>
 class.

</item>




</list>




</section>
</section>
</section>
<section id="h11004">
<title>
<emphasis id="Run_the_program" effect="bold">

Run the program

</emphasis>


</title>





<para id="p1034">
I encourage you to copy the code from 

<link id="a1063" target-id="Listing_5">

Listing 5

</link>

 through 

<link id="a1064" target-id="Listing_9">

Listing 9

</link>

. Compile the code and 
execute it. Experiment with the code, 
making changes, and observing the results of your changes. Make certain that you 
can explain why your changes behave as they do.

</para>


	

</section>
<section id="h11005">
<title>
<emphasis id="Miscellaneous" effect="bold">

Miscellaneous

</emphasis>


</title>


	

<para id="p1035">
This section contains a variety of miscellaneous information.

</para>





	

<note id="note1000" type="">


		


			


				

<emphasis id="strong1070" effect="bold">
Housekeeping material

</emphasis>

				

<list id="ul1014" list-type="bulleted">

					

<item id="li1050">
Module name: Jbs2030-A Pure Sinusoidal Tone

</item>


					

<item id="li1051">
File: Jbs2030.htm


</item>


					

<item id="li1052">
Published: 08/27/14

</item>


					

<item id="li1053">
Revised: 09/29/15

</item>


				

</list>


				

</note>

			


		



	






	

<note id="note1001" type="">


		


			


				

<emphasis id="strong1071" effect="bold">
Disclaimers:

</emphasis>
<para id="p1036">
<emphasis id="strong1072" effect="bold">
Financial

</emphasis>
: 
				Although the 

<emphasis id="strong1073" effect="bold">
OpenStax CNX

</emphasis>
 site makes it 
				possible for you to download a PDF file for the collection that 
				contains this module at no charge, and also makes it possible 
				for you to purchase a pre-printed version of the PDF file, you 
				should be aware that some of the HTML elements in this module 
				may not translate well into PDF.

</para>


				

<para id="p1037">
You also need to know that Prof. Baldwin receives no 
				financial compensation from 

<emphasis id="strong1074" effect="bold">
OpenStax CNX 

</emphasis>
even 
				if you purchase the PDF version of the collection.

</para>


				

<para id="p1038">
In the past, unknown individuals have copied Prof. Baldwin's 
				modules from cnx.org, converted them to Kindle books, and placed 
				them for sale on Amazon.com showing Prof. Baldwin as the author. 
				Prof. Baldwin neither receives compensation for those sales nor 
				does he know who does receive compensation. If you purchase such 
				a book, please be aware that it is a copy of a collection that 
				is freely available on 

<emphasis id="strong1075" effect="bold">
OpenStax CNX

</emphasis>
 and that it 
				was made and published without the prior knowledge of Prof. 
				Baldwin.

</para>


				

<para id="p1039">
<emphasis id="strong1076" effect="bold">
Affiliation

</emphasis>
: Prof. Baldwin is a professor of 
				Computer Information Technology at Austin Community College in 
				Austin, TX. 

</para>


				

</note>

			


		



	





</section>
<section id="h11006">
<title>
<emphasis id="Complete_program_listing" effect="bold">

Complete program listings

</emphasis>


</title>




<para id="p1040">
Complete listings of the classes discussed in this module are provided below.

</para>




	

<table id="table1004" summary="This is a table." pgwide="630">
<tgroup cols="1">


		

<thead id="thead1004">

			

<row id="tr1008">

				

<entry id="th1004">
<emphasis id="Listing_5" effect="bold">

Listing 5

</emphasis>

. The class named 
				AudioFormatParameters01.

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1004">

			

<row id="tr1009">

				

<entry id="td1004">



<code id="pre1004" display="block">
/*File AudioFormatParameters01.java
Copyright 2014, R.G.Baldwin
Revised 08/16/14
******************************************************************************/

public class AudioFormatParameters01{
  //The following are audio format parameters used by the Java audio system.
  // They may be modified by the signal generator at runtime.  Values allowed
  // by Java SDK 1.4.1 are shown in comments.
  public float sampleRate = 16000.0F;
  //Allowable 8000,11025,16000,22050,44100 samples per second
  public int sampleSizeInBits = 16;
  //Allowable 8,16
  public int channels = 1;
  //Allowable 1 for mono and 2 for stereo
  public boolean signed = true;
  //Allowable true,false
  public boolean bigEndian = true;
  //Allowable true,false
}//end class AudioFormatParameters01
//===========================================================================//
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>






<para id="p1041">
..

</para>





	

<table id="table1005" summary="This is a table." pgwide="630">
<tgroup cols="1">


		

<thead id="thead1005">

			

<row id="tr1010">

				

<entry id="th1005">
<emphasis id="Listing_6" effect="bold">

Listing 6

</emphasis>

. The class named 
				AudioPlayOrFile01.

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1005">

			

<row id="tr1011">

				

<entry id="td1005">



<code id="pre1005" display="block">
/*File AudioPlayOrFile01.java
Copyright 2014, R.G.Baldwin
Revised 08/16/14
******************************************************************************/
import javax.sound.sampled.*;
import java.io.*;
import java.util.*;

public class AudioPlayOrFile01{
  //An object of this class is used to either play the sound in the array
  // named melody or to write it into an audio file of type AU.
  
  //The following are general instance variables used to create a
  // SourceDataLine object.
  AudioFormat audioFormat;
  AudioInputStream audioInputStream;
  SourceDataLine sourceDataLine;

  AudioFormatParameters01 audioParams;
  byte[] melody;
  String playOrFile;//"play" to play immediately or a fileName to write
                    // an output file of type AU.
  //-------------------------------------------------------------------------//
  
  public AudioPlayOrFile01(AudioFormatParameters01 audioParams,
                           byte[] melody,
                           String playOrFile){//constructor

    this.audioParams = audioParams;
    this.melody = melody;
    this.playOrFile = playOrFile;
  }//end constructor
  //-------------------------------------------------------------------------//

  //This method plays or files the synthetic audio data that has been generated
  // and saved in an array.
  void playOrFileData() {
    try{
      //Get an input stream on the byte array containing the data
      InputStream byteArrayInputStream = new ByteArrayInputStream(melody);

      //Get the required audio format
      audioFormat = new AudioFormat(audioParams.sampleRate,
                                    audioParams.sampleSizeInBits,
                                    audioParams.channels,
                                    audioParams.signed,
                                    audioParams.bigEndian);

      //Get an audio input stream from the ByteArrayInputStream
      audioInputStream = new AudioInputStream(
                                     byteArrayInputStream,
                                     audioFormat,
                                     melody.length/audioFormat.getFrameSize());

      //Get info on the required data line
      DataLine.Info dataLineInfo = new DataLine.Info(SourceDataLine.class,
                                                     audioFormat);

      //Get a SourceDataLine object
      sourceDataLine = (SourceDataLine)AudioSystem.getLine(dataLineInfo);
                                   
      //Decide whether to play the audio data immediately, or to write it
      // into an audio file of type AU based on the incoming parameter named
      // playOrFile.
      if(playOrFile.toUpperCase().equals("PLAY")){
        //Create a thread to play back the data and start it running.  It will
        // run until all the data has been played back
        new PlayAudioThread().start();
      }else{
        //Write the data to an output file with the name provided by the
        // incoming parameter named playOrFile.
        try{
          AudioSystem.write(audioInputStream,
                            AudioFileFormat.Type.AU,
                            new File(playOrFile + ".au"));
        }catch (Exception e) {
          e.printStackTrace();
          System.exit(0);
        }//end catch
      }//end else
    }catch (Exception e) {
      e.printStackTrace();
      System.exit(0);
    }//end catch
  }//end playOrFileData
//===========================================================================//

  //Inner class to play back the data that was saved.
  class PlayAudioThread extends Thread{
    //This is a working buffer used to transfer the data between the
    // AudioInputStream and the SourceDataLine.  The size is rather arbitrary.
    byte playBuffer[] = new byte[16384];
  
    public void run(){
      try{
        //Open and start the SourceDataLine
        sourceDataLine.open(audioFormat);
        sourceDataLine.start();
  
        int cnt;
        //Get beginning of elapsed time for playback
        long startTime = new Date().getTime();
  
        //Transfer the audio data to the speakers
        while((cnt = audioInputStream.read(
                                       playBuffer,0,playBuffer.length)) != -1){
          //Keep looping until the input read method returns -1 for empty
          // stream.
          if(cnt &gt; 0){
            //Write data to the internal buffer of the data line where it will
            // be delivered to the speakers in real time
            sourceDataLine.write(playBuffer, 0, cnt);
          }//end if
        }//end while
  
        //Block and wait for internal buffer of the SourceDataLine to become
        // empty.
        sourceDataLine.drain();
  
  
        //Get and display the elapsed time for the previous playback.
        int elapsedTime = (int)(new Date().getTime() - startTime);
        System.out.println("Elapsed time: " + elapsedTime);
  
        //Finish with the SourceDataLine
        sourceDataLine.stop();
        sourceDataLine.close();
      }catch (Exception e) {
        e.printStackTrace();
        System.exit(0);
      }//end catch
  
    }//end run
  }//end inner class PlayAudioThread
  //=========================================================================//
}//end AudioPlayOrFile01 class
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>






<para id="p1042">
..

</para>





	

<table id="table1006" summary="This is a table." pgwide="630">
<tgroup cols="1">


		

<thead id="thead1006">

			

<row id="tr1012">

				

<entry id="th1006">
<emphasis id="Listing_7" effect="bold">

Listing 7

</emphasis>

. The class named 
				AudioSignalGenerator02.

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1006">

			

<row id="tr1013">

				

<entry id="td1006">



<code id="pre1006" display="block">
/*File AudioSignalGenerator02.java
Copyright 2014, R.G.Baldwin
Revised 08/19/14

This is an abstract class that serves as the base class for several other 
classes that can be used to create melodies of different types.
******************************************************************************/

import java.io.*;
import java.nio.*;
import java.util.*;

public abstract class AudioSignalGenerator02{
  
  //Note:  This class can only be used to generate signed 16-bit data.
  ByteBuffer byteBuffer;
  String[] args;
  byte[] melody;
  AudioFormatParameters01 audioParams;
  //-------------------------------------------------------------------------//
  
  //Constructor
  public AudioSignalGenerator02(AudioFormatParameters01 audioParams,
                                String[] args,
                                byte[] melody){
    this.audioParams = audioParams;
    this.args = args;
    this.melody = melody;
  }//end constructor
  //-------------------------------------------------------------------------//

  //The following abstract method must be overridden in a subclass for this
  // class to be of any value.
  abstract byte[] getMelody();
}//end AudioSignalGenerator02
//===========================================================================//
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>






<para id="p1043">
..

</para>





	

<table id="table1007" summary="This is a table." pgwide="630">
<tgroup cols="1">


		

<thead id="thead1007">

			

<row id="tr1014">

				

<entry id="th1007">
<emphasis id="Listing_8" effect="bold">

Listing 8

</emphasis>

. The class named 
				MusicComposer06.

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1007">

			

<row id="tr1015">

				

<entry id="td1007">



<code id="pre1007" display="block">
/*File MusicComposer06.java
Copyright 2014, R.G.Baldwin
Revised 08/22/14

This program works in conjunction with the following classes to create and play
three seconds of monaural audio based on a pure sinusoidal function at 1000 
cycles per second.

ToneMono
AudioSignalGenerator02
AudioPlayOrFile01
AudioFormatParameters01

The sound can be played immediately or can be saved in an audio file of 
type AU for playback later. You should be able to play the audio file with any
standard media player that can handle the AU file type

Tested using JDK 1.8 under Win 7.
******************************************************************************/

public class MusicComposer06{
  //Instantiate an object containing audio format parameters with predefined
  // values. They may be modified by the signal generator at runtime. Values
  // allowed by Java SDK 1.4.1 are shown in comments in the class definition.
  AudioFormatParameters01 audioParams = new AudioFormatParameters01();
  
  //A buffer to hold the audio data that will be played or filed.
  byte[] melody;
  
  //A place to store the incoming args array.
  String[] args; 
  //-------------------------------------------------------------------------//

  //Command-line parameter (only one parameter is needed)
  //If "play", the sound will be played immediately. Otherwise, the string will
  // be used as a filename for an audio file of type AU. In the latter case,
  // it must be a string that would be valid as a file name for the operating
  // system in use.  
  public static void main(String[] args){
    //Instantiate a new object of this class.
    new MusicComposer06(args);
  }//end main
  //-------------------------------------------------------------------------//
  
  public MusicComposer06(String[] args){//constructor
    //Save the args array.
    this.args = args;
    
    //Create default args data if no args data is provided on the command line.
    if(args.length == 0){
      this.args = new String[1];
      this.args[0] = "play";//Play the melody immediately
    }//end if

    //Get a populated array containing audio data for the pure sinusoidal tone.
    ToneMono toneMono = new ToneMono(audioParams,this.args,melody);
    melody = toneMono.getMelody();

    //Play or file the audio data
    new AudioPlayOrFile01(audioParams,melody,this.args[0]).playOrFileData();
  }//end constructor
  //-------------------------------------------------------------------------//
}//end class MusicComposer06.java
//===========================================================================//
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>






<para id="p1044">
..

</para>





	

<table id="table1008" summary="This is a table." pgwide="630">
<tgroup cols="1">


		

<thead id="thead1008">

			

<row id="tr1016">

				

<entry id="th1008">
<emphasis id="Listing_9" effect="bold">

Listing 9

</emphasis>

. The class named 
				ToneMono.

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1008">

			

<row id="tr1017">

				

<entry id="td1008">



<code id="pre1008" display="block">
/*File ToneMono.java
Copyright 2014, R.G.Baldwin
Revised 08/22/14

This class that can be used to create a melody consisting of a single pure 
sinusoidal tone at 1000 Hz.

The class introduces the use of ByteBuffer.
******************************************************************************/

import java.io.*;
import java.nio.*;
import java.util.*;

public class ToneMono extends AudioSignalGenerator02{
  
  public ToneMono(AudioFormatParameters01 audioParams,
                     String[] args,
                     byte[] melody){
    super(audioParams,args,melody);
  }//end constructor
  //-------------------------------------------------------------------------//
  

  //This method generates a three-second pure sinusoidal tone. A 1000 Hz tone
  // is emitted with equal amplitude from the left and right speakers. It is
  // interesting to compare this sound with the sound of a square wave with
  // the same fundamental frequency.

  byte[] getMelody(){
    //Recall that the default is channels=1 for monaural.
    System.out.println("audioParams.channels = " + audioParams.channels);
    
    //Each channel requires two 8-bit bytes per 16-bit sample.
    int bytesPerSampPerChan = 2;
    
    //Override the default sample rate. Allowable sample rates are 8000,11025,
    // 16000,22050,44100 samples per second.
    audioParams.sampleRate = 8000.0F;
    
    // Set the length of the melody in seconds
    double lengthInSeconds = 3.0;
    
    //Set the frequency of the tone.
    double freq = 1000.0;
    
    //Create an output data array sufficient to contain the tone
    // at "sampleRate" samples per second, "bytesPerSampPerChan" bytes per
    // sample per channel and "channels" channels.
    melody = new byte[(int)(lengthInSeconds*audioParams.sampleRate*
                                    bytesPerSampPerChan*audioParams.channels)];
    System.out.println("melody.length = " + melody.length);
    
    //Prepare a ByteBuffer for use
    byteBuffer = ByteBuffer.wrap(melody);

    //Compute the number of audio samples in the melody.
    int sampLength = (int)(lengthInSeconds*audioParams.sampleRate);
    
    //Compute the audio sample values and deposit them in the output array.
    for(int cnt = 0; cnt &lt; sampLength; cnt++){
      //Compute the time in seconds for this sample.
      double time = cnt/audioParams.sampleRate;

      //Deposit audio data for both channels in mono. 
      byteBuffer.putShort((short)(8000*Math.sin(2*Math.PI*freq*time)));

    }//end for loop
    
    return melody;
  }//end method getMelody
  //-------------------------------------------------------------------------//

}//end class ToneMono 
//===========================================================================//
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>






<para id="p1045">
-end- 

</para>






</section>
</content>




</document>